<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Path2 (OCADml.OCADml.Path2)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">OCADml</a> &#x00BB; <a href="../index.html">OCADml</a> &#x00BB; Path2</nav><header class="odoc-preamble"><h1>Module <code><span>OCADml.Path2</span></code></h1><p>2d path generation (including arcs and basic shapes), manipulation (including offset and roundovers (see <a href="Round/index.html"><code>Round</code></a>), and measurement.</p></header><nav class="odoc-toc"><ul><li><a href="#construction-/-conversion">Construction / Conversion</a></li><li><a href="#general-path-utilities">General Path Utilities</a></li><li><a href="#search">Search</a></li><li><a href="#creation-and-2d-3d-conversion">Creation and 2d-3d conversion</a></li><li><a href="#basic-shapes">Basic Shapes</a></li><li><a href="#drawing-arcs-and-splines">Drawing Arcs and Splines</a></li><li><a href="#roundovers">Roundovers</a></li><li><a href="#geometry">Geometry</a></li><li><a href="#path-matching-/-vertex-association">Path Matching / Vertex Association</a></li><li><a href="#basic-transfomations">Basic Transfomations</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><a href="../V2/index.html#type-t">V2.t</a> list</span></span></code></div></div><h2 id="construction-/-conversion"><a href="#construction-/-conversion" class="anchor"></a>Construction / Conversion</h2><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_list l</code></p><p>Construct a path from a list of points <code>l</code> (no-op).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><a href="../V2/index.html#type-t">V2.t</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_seq s</code></p><p>Construct a path from a sequence of points <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span><span class="keyword">val</span> of_array : <span><span><a href="../V2/index.html#type-t">V2.t</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_array a</code></p><p>Construct a path from an array of points <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> list</span></span></code></div><div class="spec-doc"><p><code>to_list t</code></p><p>Convert the path <code>t</code> to a list of points (no-op).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_seq t</code></p><p>Convert the path <code>t</code> to a sequence of points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span><span class="keyword">val</span> to_array : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> array</span></span></code></div><div class="spec-doc"><p><code>to_array t</code></p><p>Convert the path <code>t</code> to a array of points.</p></div></div><h2 id="general-path-utilities"><a href="#general-path-utilities" class="anchor"></a>General Path Utilities</h2><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>length ?closed path</code></p><p>Calculate the length (total travel distance) of the <code>path</code>. If <code>closed</code> is <code>true</code>, include the distance between the endpoints (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cummulative_length"><a href="#val-cummulative_length" class="anchor"></a><code><span><span class="keyword">val</span> cummulative_length : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float list</span></span></code></div><div class="spec-doc"><p><code>cummulative_length ?closed path</code></p><p>Calculate the cummulative length (distance travelled by each point) along the <code>path</code>. If <code>closed</code> is <code>true</code>, include the distance between the endpoints (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_continuous"><a href="#val-to_continuous" class="anchor"></a><code><span><span class="keyword">val</span> to_continuous : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="../V2/index.html#type-t">V2.t</a></span></code></div><div class="spec-doc"><p><code>to_continuous path</code></p><p>Return a continuous function from values over the range of <code>0.</code> to <code>1.</code> to positions along <code>path</code> (like a bezier function), treated as open (<code>closed = false</code>) by default.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-resample"><a href="#val-resample" class="anchor"></a><code><span><span class="keyword">val</span> resample : <span>freq:<span>[&lt; <span>`N of int</span> <span><span>| `Spacing</span> of float</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>resample ~freq path</code></p><p>Resample <code>path</code> with the given <code>freq</code>uency (either a flat number of points, or a target point spacing). Note that the only points guaranteed to appear in the output are the start and end points of <code>path</code>. For upsampling that preserves input points, see <a href="#val-subdivide"><code>subdivide</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subdivide"><a href="#val-subdivide" class="anchor"></a><code><span><span class="keyword">val</span> subdivide : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>freq:
    <span>[ <span>`N of int * <span>[ `ByLen <span>| `BySeg</span> ]</span></span>
    <span><span>| `RoughN</span> of int * <span>[ `ByLen <span>| `BySeg</span> ]</span></span>
    <span><span>| `Refine</span> of int * <span>[ `ByLen <span>| `BySeg</span> ]</span></span>
    <span><span>| `RoughRefine</span> of int * <span>[ `ByLen <span>| `BySeg</span> ]</span></span>
    <span><span>| `Spacing</span> of float</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> list</span></span></code></div><div class="spec-doc"><p><code>subdivide ?closed ~freq path</code></p><p>Subdivides <code>path</code> with given <code>freq</code>uency, including each of the original points in the output (unlike <a href="#val-resample"><code>resample</code></a>). This can be a flat number of points provided directly with <code>`N (n, by)</code>, or as a multiple of number of points in <code>path</code> with <code>`Refine (factor, by)</code>. The strategy for distribution of points for these count based methods is set with the second parameter <code>by</code>, which can be either <code>`BySeg</code> (same number of additional points per segment) and <code>`ByLen</code> (segments gain new points proportional to their length). Alternatively, a maximum <code>`Spacing dist</code> can be specified instead. The <code>`Rough</code> point sampling variants will favour sampling uniformity, at the expense of not adhering exactly to the requested point count.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cut"><a href="#val-cut" class="anchor"></a><code><span><span class="keyword">val</span> cut : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>distances:<span>[ <span>`Abs of <span>float list</span></span> <span><span>| `Rel</span> of <span>float list</span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>cut ?closed ~distances path</code></p><p>Cut <code>path</code> at a list of increasing <code>distances</code> (<code>`Abs</code>olute or <code>`Rel</code>ative) along it from the start. If <code>closed</code> is <code>true</code>, the segment between the end and beginning of <code>path</code> will be considered, and the first point will be the last of the second path returned. Negative <code>`Abs distance</code> will start from the end to find the split point. Raises <code>Invalid_argument</code> if <code>distance</code> is an endpoint, or further than the end of the <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>distance:<span>[ <span>`Abs of float</span> <span><span>| `Rel</span> of float</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>split ?closed ~distance path</code></p><p>Split <code>path</code> into two at the position <code>distance</code> (<code>`Abs</code>olute or <code>`Rel</code>ative) along <code>path</code> from the start. Otherwise the behaviour is the same as <a href="#val-cut"><code>cut</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-noncollinear_triple"><a href="#val-noncollinear_triple" class="anchor"></a><code><span><span class="keyword">val</span> noncollinear_triple : 
  <span>?eps:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>(int * int * int)</span> * <span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>noncollinear_triple ?eps path</code></p><p>Returns a pair of triples of non-collinear indices and the corresponding points from <code>path</code> (if the path is not completely collinear). Two well separated points are selected, and the third point is the furthest off the line drawn by the first two points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_collinear"><a href="#val-is_collinear" class="anchor"></a><code><span><span class="keyword">val</span> is_collinear : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_collinear ?eps path</code></p><p>Returns <code>true</code> if all points in <code>path</code> are collinear (fall within <code>eps</code> distance of the same line).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prune_collinear"><a href="#val-prune_collinear" class="anchor"></a><code><span><span class="keyword">val</span> prune_collinear : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>prune_collinear path</code></p><p>Remove collinear points from <code>path</code>. If <code>closed</code> is <code>true</code> the last point can be pruned as collinear with the first. The first point is never pruned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deduplicate_consecutive"><a href="#val-deduplicate_consecutive" class="anchor"></a><code><span><span class="keyword">val</span> deduplicate_consecutive : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?keep:<span>[ `First <span>| `Last</span> <span>| `FirstAndEnds</span> <span>| `LastAndEnds</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?eq:<span>(<span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>deduplicate_consecutive ?closed ?keep ?eq path</code></p><p>Remove consecutive duplicate points as determined by the (approximate) equality function <code>eq</code> (<code>V.approx ~eps:1e-9</code> by default) from <code>path</code>. By default <code>keep</code> is <code>`First</code>, which includes the first point of each run of duplicates in the output. This can be instead be set to <code>keep</code> the <code>`Last</code>, or to <code>`FirstAndEnds</code> or <code>`LastAndEnds</code>, which follow their respective simpler rules with the caveat of preserving the endpoints (first and last points) of the path. The path is treated as open (<code>closed = false</code>) by default, if <code>closed</code> is <code>true</code> the last point of the path may be dropped (even if <code>keep</code> is <code>`FirstAndEnds | `LastAndEnds</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deriv"><a href="#val-deriv" class="anchor"></a><code><span><span class="keyword">val</span> deriv : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span>?h:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>deriv ?closed ?h path</code></p><p>Computes a numerical derivative of <code>path</code>, with <code>h</code> (default <code>1.</code>) giving the step size of the sampling of <code>path</code>, so that the derivative can be scaled correctly. Setting <code>closed</code> to <code>true</code> will include computation of the derivative between the last and first point of the <code>path</code> (default <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deriv_nonuniform"><a href="#val-deriv_nonuniform" class="anchor"></a><code><span><span class="keyword">val</span> deriv_nonuniform : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span>h:<span>float list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>deriv_nonuniform ?closed ?h path</code></p><p>Computes a numerical derivative of <code>path</code>, with <code>h</code> giving the non-uniform step sizes of the sampling of <code>path</code>, so that the derivative can be scaled correctly. Setting <code>closed</code> to <code>true</code> will include computation of the derivative between the last and first point of the <code>path</code> (default <code>false</code>). As <code>h</code> provides scaling factors for each segment of the path, it must have a length of one less than <code>path</code> if it's unclosed, and the same length if <code>closed</code> is <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tangents"><a href="#val-tangents" class="anchor"></a><code><span><span class="keyword">val</span> tangents : <span>?uniform:bool <span class="arrow">&#45;&gt;</span></span> <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>tangents ?uniform ?closed path</code></p><p>Compute tangent unit vectors of <code>path</code>. Set <code>closed</code> to <code>true</code> to indicate that tangents should include between the end and beginning of the path (default = <code>false</code>). Sampling of <code>path</code> is assumed to be <code>uniform</code> unless the parameter is set to <code>false</code>, in which case the derivatives will be adjusted to correct for non-uniform sampling of points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-continuous_closest_point"><a href="#val-continuous_closest_point" class="anchor"></a><code><span><span class="keyword">val</span> continuous_closest_point : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?n_steps:int <span class="arrow">&#45;&gt;</span></span>
  <span>?max_err:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>float <span class="arrow">&#45;&gt;</span></span> <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  float</span></code></div><div class="spec-doc"><p><code>continuous_closest_point ?closed ?n_steps ?max_err f p</code></p><p>Find the closest position (from <code>0.</code> to <code>1.</code>) along the path function <code>f</code> to the point <code>p</code>.</p><ul><li><code>n_steps</code> sets the granularity of search at each stage.</li><li><code>max_err</code> the maximum distance the solution can be from the target <code>p</code></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-segment"><a href="#val-segment" class="anchor"></a><code><span><span class="keyword">val</span> segment : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-line">V2.line</a> list</span></span></code></div><div class="spec-doc"><p><code>segment ?closed path</code></p><p>Break <code>path</code> into line segments. If <code>closed</code> is <code>true</code>, include a segment between the last and first points of <code>path</code> (default <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reindex_polygon"><a href="#val-reindex_polygon" class="anchor"></a><code><span><span class="keyword">val</span> reindex_polygon : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>reindex_polygon reference poly</code></p><p>Rotate the polygonal (closed / coplanar) path <code>poly</code> to optimize its pairwise point association with the <code>reference</code> polygon. Paths should have the same clockwise winding direction (not checked / corrected).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lerp"><a href="#val-lerp" class="anchor"></a><code><span><span class="keyword">val</span> lerp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>lerp a b u</code></p><p>Linearly interpolate between the paths <code>a</code> and <code>b</code>. Raises <code>Invalid_argument</code> if the paths are of unequal length.</p></div></div><h2 id="search"><a href="#search" class="anchor"></a>Search</h2><div class="odoc-spec"><div class="spec value anchored" id="val-nearby_idxs"><a href="#val-nearby_idxs" class="anchor"></a><code><span><span class="keyword">val</span> nearby_idxs : 
  <span>?min_tree_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>?radius:float <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int list</span></span></code></div><div class="spec-doc"><p><code>nearby_idxs ?min_tree_size ?radius path p</code></p><p>Find the indices of points within <code>radius</code> (default = <code>1e-9</code>) distance from the target point <code>p</code> in <code>path</code>. Match indices will be returned in arbitrary order (unsorted). When <code>path</code> is provided (eagerly on partial application), the length will be checked and a function to perform the search will be generated. If <code>path</code> is shorter than <code>min_tree_size</code>, it will be a simple direct search otherwise a <a href="../BallTree2/index.html#type-t"><code>BallTree2.t</code></a> will be constructed. Thus, if you plan to search for more than one target point, take care to apply this function in two steps to avoid repeated length checks and closure/tree generations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nearby_points"><a href="#val-nearby_points" class="anchor"></a><code><span><span class="keyword">val</span> nearby_points : 
  <span>?min_tree_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>?radius:float <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> list</span></span></code></div><div class="spec-doc"><p><code>nearby_points ?min_tree_size ?radius path</code></p><p>Find the points within <code>radius</code> (default = <code>1e-9</code>) distance from the target point <code>p</code> in <code>path</code>. Matched points will be returned in arbitrary order (unsorted). When <code>path</code> is provided (eagerly on partial application), the length will be checked and a function to perform the search will be generated. If <code>path</code> is shorter than <code>min_tree_size</code>, it will be a simple direct search otherwise a <a href="../BallTree2/index.html#type-t"><code>BallTree2.t</code></a> will be constructed. Thus, if you plan to search for more than one target point, take care to apply this function in two steps to avoid repeated length checks and closure/tree generations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-closest_tangent"><a href="#val-closest_tangent" class="anchor"></a><code><span><span class="keyword">val</span> closest_tangent : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?offset:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>line:<a href="../V2/index.html#type-line">V2.line</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  int * <a href="../V2/index.html#type-line">V2.line</a></span></code></div><div class="spec-doc"><p><code>closest_tangent ?closed ?offset ~line t</code></p><p>Find the tangent segment (and its index) on the curved path <code>t</code> closest to <code>line</code> after <code>offset</code> (default = <code>V2.zero</code>) is applied to the points of <code>t</code> (can be used to centre the path relative to <code>line</code> to help in choosing the desired tangent).</p></div></div><h2 id="creation-and-2d-3d-conversion"><a href="#creation-and-2d-3d-conversion" class="anchor"></a>Creation and 2d-3d conversion</h2><div class="odoc-spec"><div class="spec value anchored" id="val-of_tups"><a href="#val-of_tups" class="anchor"></a><code><span><span class="keyword">val</span> of_tups : <span><span><span>(float * float)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_tups ps</code></p><p>Create a 2d path from a list of xy coordinate tuples.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_path3"><a href="#val-of_path3" class="anchor"></a><code><span><span class="keyword">val</span> of_path3 : <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_path3 p</code></p><p>Project the 3d path <code>p</code> onto the given <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_path3"><a href="#val-to_path3" class="anchor"></a><code><span><span class="keyword">val</span> to_path3 : <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>to_path3 t</code></p><p>Lift the 2d path <code>p</code> onto the given <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lift"><a href="#val-lift" class="anchor"></a><code><span><span class="keyword">val</span> lift : <span><a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>lift plane t</code></p><p>Lift the 2d path <code>t</code> onto the 3d <code>plane</code>.</p></div></div><h2 id="basic-shapes"><a href="#basic-shapes" class="anchor"></a>Basic Shapes</h2><div class="odoc-spec"><div class="spec value anchored" id="val-circle"><a href="#val-circle" class="anchor"></a><code><span><span class="keyword">val</span> circle : <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>?fa:float <span class="arrow">&#45;&gt;</span></span> <span>?fs:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>circle ?fn ?fa ?fs r</code></p><p>Create a circular path of radius <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-square"><a href="#val-square" class="anchor"></a><code><span><span class="keyword">val</span> square : <span>?center:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>square ?center dims</code></p><p>Create a rectangular path with xy <code>dims</code> (e.g. width and height). If <code>center</code> is <code>true</code> then the path will be centred around the origin (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ellipse"><a href="#val-ellipse" class="anchor"></a><code><span><span class="keyword">val</span> ellipse : <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>?fa:float <span class="arrow">&#45;&gt;</span></span> <span>?fs:float <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>ellipse ?fn ?fa ?fs radii</code></p><p>Draw an ellipse with xy <code>radii</code>. The greater of the two radii is used for fragment/resolution calculation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-star"><a href="#val-star" class="anchor"></a><code><span><span class="keyword">val</span> star : <span>r1:float <span class="arrow">&#45;&gt;</span></span> <span>r2:float <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>star ~r1 ~r2 n</code></p><p>Draw an <code>n</code> pointed star with inner radius <code>r1</code> and outer radius <code>r2</code>.</p></div></div><h2 id="drawing-arcs-and-splines"><a href="#drawing-arcs-and-splines" class="anchor"></a>Drawing Arcs and Splines</h2><div class="odoc-spec"><div class="spec value anchored" id="val-arc"><a href="#val-arc" class="anchor"></a><code><span><span class="keyword">val</span> arc : 
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?wedge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>centre:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>radius:float <span class="arrow">&#45;&gt;</span></span>
  <span>start:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>arc ?rev ?fn ?fa ?fs ?wedge ~centre ~radius ~start a</code></p><p>Draw an arc of <code>a</code> radians with <code>radius</code> around the point <code>centre</code>, beginning with the angle <code>start</code>. If <code>wedge</code> is <code>true</code>, <code>centre</code> will be included as the last point of the returned path (default = <code>false</code>). If <code>rev</code> is <code>true</code>, the arc will end at <code>start</code>, rather than begin there.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-arc_about_centre"><a href="#val-arc_about_centre" class="anchor"></a><code><span><span class="keyword">val</span> arc_about_centre : 
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?dir:<span>[ `CW <span>| `CCW</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?wedge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>centre:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>arc_about_centre ?rev ?fn ?fa ?fs ?dir ?wedge ~centre p1 p2</code></p><p>Draw an arc between the points <code>p1</code> and <code>p2</code>, about <code>centre</code>. <code>dir</code> can be provided to enforce clockwise or counter-clockwise winding direction. By default, the direction is computed automatically, though if <code>centre</code>, <code>p1</code>, and <code>p2</code> do not form a valid triangle (they're collinear), an <code>Invalid_argument</code> exception will be raised if <code>dir</code> is not provided.</p><ul><li>See <a href="#val-arc"><code>arc</code></a> for notes on <code>rev</code> and <code>wedge</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-arc_through"><a href="#val-arc_through" class="anchor"></a><code><span><span class="keyword">val</span> arc_through : 
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?wedge:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>arc_through ?rev ?fn ?fa ?fs ?wedge p1 p2 p3</code></p><p>Draw an arc through the points <code>p1</code>, <code>p2</code>, and <code>p3</code>. If the points do not form a valid triangle (they're collinear), an <code>Invalid_argument</code> exception will be raised.</p><ul><li>See <a href="#val-arc"><code>arc</code></a> for notes on <code>rev</code>, and <code>wedge</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cubic_spline"><a href="#val-cubic_spline" class="anchor"></a><code><span><span class="keyword">val</span> cubic_spline : <span>?boundary:<a href="../CubicSpline/index.html#type-boundary">CubicSpline.boundary</a> <span class="arrow">&#45;&gt;</span></span> <span>fn:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>cubic_spline ?boundary ~fn ps</code></p><p>Calculate a cubic spline with the given <code>boundary</code> condition (defaults to <code>`Natural</code>) for the 2-dimensional control points <code>ps</code>, and immediately interpolate a path of <code>fn</code> points along it. See the <a href="../CubicSpline/index.html"><code>CubicSpline</code></a> module for more details.</p></div></div><h2 id="roundovers"><a href="#roundovers" class="anchor"></a>Roundovers</h2><p>Outline offsets with optional rounding/chamfering as found in OpenSCADs 2d sub-system, as well as specification and application of non-offseting roundovers (circular, chamfer, and bezier (continuous curvature)) to 2d paths.</p><p>Based on the <a href="https://github.com/revarbat/BOSL2">BOSL2</a> <a href="https://github.com/revarbat/BOSL2/blob/master/rounding.scad">rounding</a> module.</p><div class="odoc-spec"><div class="spec value anchored" id="val-offset"><a href="#val-offset" class="anchor"></a><code><span><span class="keyword">val</span> offset : 
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?mode:<span>[&lt; `Chamfer <span>| `Delta</span> <span>| `Radius</span> Delta ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>offset ?fn ?fs ?fa ?closed ?check_valid ?mode d path</code></p><p>Offset a 2d <code>path</code> (treated as <code>closed</code> by default) by the specified distance <code>d</code>.The <code>mode</code> governs how <code>d</code> is used to create the new corners.</p><ul><li><code>`Delta</code> will create a new outline whose sides are a fixed distance <code>d</code> (+ve out, -ve in) from the original outline (this is the default behaviour).</li><li><code>`Chamfer</code> fixed distance offset by <code>d</code> as with delta, but with corners chamfered.</li><li><code>`Radius</code> creates a new outline as if a circle of some radius <code>d</code> is rotated around the exterior (<code>d &gt; 0</code>) or interior (<code>d &lt; 0</code>) original outline. <code>fn</code>, <code>fs</code>, and <code>fa</code> parameters govern the number of points that will be used for these arcs (they are ignored for delta and chamfer modes).</li><li>The <code>check_valid</code> default of <code>`Quality 1</code> will check the validity of shifted line segments by checking whether their ends and <code>n</code> additional points spaced throughout are far enough from the original path. If there are no points that have been offset by the target <code>d</code>, a <code>Failure</code> exception will be raised. Checking can be turned off by setting this to <code>`No</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Round"><a href="#module-Round" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Round/index.html">Round</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Configuration module with types and helpers for specifying path roundovers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundover"><a href="#val-roundover" class="anchor"></a><code><span><span class="keyword">val</span> roundover : 
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?overrun:<span>[ `Fail <span>| `Warn</span> <span>| `Fix</span> <span>| `NoCheck</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Round/index.html#type-t">Round.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> list</span></span></code></div><div class="spec-doc"><p><code>roundover ?fn ?fa ?fs ?overrun path_spec</code></p><p>Apply the roundover specifictions in <code>path_spec</code> on the bundled path/shape, with quality set by the <code>fn</code>, <code>fa</code>, and <code>fs</code> parameters. Collinear points are ignored (included in output without roundover applied).</p><p>When <code>overrun</code> is set to <code>`Fail</code> (as it is by default) this function will raise <code>Failure</code> if computed joint distances would lead to point insertion that causes the path to reverse/double back on itself. Alternatively:</p><ul><li><code>`Warn</code> will print the detected overruns to <code>stdout</code> rather than raising <code>Failure</code> (useful for debuggin)</li><li><code>`Fix</code> will automatically reduce the corner joints involved in each overrun proportional to their lengths.</li><li><code>`NoCheck</code> skips overrun detection</li></ul></div></div><h2 id="geometry"><a href="#geometry" class="anchor"></a>Geometry</h2><div class="odoc-spec"><div class="spec value anchored" id="val-clockwise_sign"><a href="#val-clockwise_sign" class="anchor"></a><code><span><span class="keyword">val</span> clockwise_sign : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>clockwise_sign path</code></p><p>Returns the rotational ordering of <code>path</code> as a signed float, <code>-1.</code> for clockwise, and <code>1.</code> for counter-clockwise. If all points are collinear (within the tolerance of <code>eps</code>), <code>0.</code> is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_clockwise"><a href="#val-is_clockwise" class="anchor"></a><code><span><span class="keyword">val</span> is_clockwise : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_clockwise path</code></p><p>Returns <code>true</code> if the rotational ordering of <code>path</code> is clockwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-self_intersections"><a href="#val-self_intersections" class="anchor"></a><code><span><span class="keyword">val</span> self_intersections : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>self_intersection ?eps ?closed path</code></p><p>Find the points at which <code>path</code> intersects itself (within the tolerance of <code>eps</code>). If <code>closed</code> is <code>true</code>, a line segment between the last and first points will be considered (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_simple"><a href="#val-is_simple" class="anchor"></a><code><span><span class="keyword">val</span> is_simple : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_simple ?eps ?closed path</code></p><p>Return <code>true</code> if <code>path</code> is simple, e.g. contains no (paralell) reversals or self-intersections (within the tolerance <code>eps</code>). If <code>closed</code> is <code>true</code>, a line segment between the last and first points will be considered (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bbox"><a href="#val-bbox" class="anchor"></a><code><span><span class="keyword">val</span> bbox : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Gg</span>.Box2.t</span></code></div><div class="spec-doc"><p><code>bbox t</code></p><p>Compute the 2d bounding box of the path <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-centroid"><a href="#val-centroid" class="anchor"></a><code><span><span class="keyword">val</span> centroid : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../V2/index.html#type-t">V2.t</a></span></code></div><div class="spec-doc"><p><code>centroid ?eps t</code></p><p>Compute the centroid of the path <code>t</code>. If <code>t</code> is collinear or self-intersecting (within <code>eps</code> tolerance), an <code>Invalid_argument</code> exception is raised.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-area"><a href="#val-area" class="anchor"></a><code><span><span class="keyword">val</span> area : <span>?signed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>area ?signed t</code></p><p>Compute the signed or unsigned area of the path <code>t</code> (unsigned by default).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-point_inside"><a href="#val-point_inside" class="anchor"></a><code><span><span class="keyword">val</span> point_inside : 
  <span>?eps:float <span class="arrow">&#45;&gt;</span></span>
  <span>?nonzero:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>[&gt; `Inside <span>| `OnBorder</span> <span>| `Outside</span> ]</span></span></code></div><div class="spec-doc"><p><code>point_inside ?eps ?nonzero t p</code></p><p>Determine whether the point <code>p</code> is inside, on the border of, or outside the closed path <code>t</code> (may be non-simple / contain self-intersections). If <code>nonzero</code> is <code>true</code>, the <a href="https://en.wikipedia.org/wiki/Nonzero-rule">Nonzero rule</a> is followed, wherein a point is considered inside the polygon formed by <code>t</code> regardless of the number of times the containing regions overlap, by default this is <code>false</code>, and the <a href="https://en.wikipedia.org/wiki/Even–odd_rule">Even-Odd rule</a> is followed (as with in OpenSCAD).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hull"><a href="#val-hull" class="anchor"></a><code><span><span class="keyword">val</span> hull : <span>?all:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>hull ?all t</code></p><p>Compute the convex hull polygon that encloses the points in the path <code>t</code>. When <code>all</code> is <code>true</code>, the output path will include the non-vertex points resting on the edges of the hull (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-triangulate"><a href="#val-triangulate" class="anchor"></a><code><span><span class="keyword">val</span> triangulate : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>triangulate ?eps t</code></p><p>Break the polygon <code>t</code> into a list of triangles. If provided, <code>eps</code> is used for duplicate point and collinearity checks.</p></div></div><h2 id="path-matching-/-vertex-association"><a href="#path-matching-/-vertex-association" class="anchor"></a>Path Matching / Vertex Association</h2><p>Point duplicating strategies for associating vertices between incommensurate closed polygonal paths/profiles. Primarily for use in conjunction with <a href="../Mesh/index.html#val-skin"><code>Mesh.skin</code></a> and <a href="../Mesh/index.html#val-morphing_sweep"><code>Mesh.morphing_sweep</code></a>, where commensurate profiles are required to draw edges between.</p><p>Ported from the <a href="https://github.com/revarbat/BOSL2/blob/master/skin.scad">skin</a> module of the <a href="https://github.com/revarbat/BOSL2">BOSL2</a> OpenSCAD library.</p><div class="odoc-spec"><div class="spec value anchored" id="val-distance_match"><a href="#val-distance_match" class="anchor"></a><code><span><span class="keyword">val</span> distance_match : <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> list</span> * <span><a href="../V2/index.html#type-t">V2.t</a> list</span></span></code></div><div class="spec-doc"><p><code>distance_match a b</code></p><p>If the closed polygonal paths <code>a</code> and <code>b</code> have incommensurate lengths, points on the smaller path are duplicated and the larger path is shifted (list rotated) in such a way that the total length of the edges between the associated vertices (same index/position) is minimized. The replacement paths, now having the same lengths, are returned as a pair (with the same order). This algorithm generally produces a good result when both <code>a</code> and <code>b</code> are discrete profiles with a small number of vertices.</p><p>This is computationally intensive ( <b>O(N<sup>3</sup>)</b> ), if the profiles are already known to be lined up, with their zeroth indices corresponding, then <a href="#val-aligned_distance_match"><code>aligned_distance_match</code></a> provides a ( <b>O(N<sup>2</sup>)</b> ) solution.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-aligned_distance_match"><a href="#val-aligned_distance_match" class="anchor"></a><code><span><span class="keyword">val</span> aligned_distance_match : <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> list</span> * <span><a href="../V2/index.html#type-t">V2.t</a> list</span></span></code></div><div class="spec-doc"><p><code>aligned_distance_match a b</code></p><p>Like <a href="#val-distance_match"><code>distance_match</code></a>, but the paths <code>a</code> and <code>b</code> are assumed to already be &quot;lined up&quot;, with the zeroth indices in each corresponding to one another.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tangent_match"><a href="#val-tangent_match" class="anchor"></a><code><span><span class="keyword">val</span> tangent_match : <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../V2/index.html#type-t">V2.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> list</span> * <span><a href="../V2/index.html#type-t">V2.t</a> list</span></span></code></div><div class="spec-doc"><p><code>tangent_match a b</code></p><p>If the closed polygonal paths <code>a</code> and <code>b</code> have incommensurate lengths, points on the larger (ideally convex, curved) path are grouped by association of their tangents with the edges of the smaller (ideally discrete) polygonal path. The points of the smaller path are then duplicated to associate with their corresponding spans of tangents on the curve, and the larger path is rotated to line up the indices. The profiles, now having the same length are returned as a pair in the order that they were applied returned.</p><p>This algorithm generally produces good results when connecting a discrete polygon to a <i>convex</i> finely sampled curve. It may fail if the curved profile is non-convex, or doesn't have enough points to distinguish all of the tangent points from each other.</p></div></div><h2 id="basic-transfomations"><a href="#basic-transfomations" class="anchor"></a>Basic Transfomations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-translate"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xtrans"><a href="#val-xtrans" class="anchor"></a><code><span><span class="keyword">val</span> xtrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ytrans"><a href="#val-ytrans" class="anchor"></a><code><span><span class="keyword">val</span> ytrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rotate"><a href="#val-rotate" class="anchor"></a><code><span><span class="keyword">val</span> rotate : <span>?about:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zrot"><a href="#val-zrot" class="anchor"></a><code><span><span class="keyword">val</span> zrot : <span>?about:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-affine"><a href="#val-affine" class="anchor"></a><code><span><span class="keyword">val</span> affine : <span><a href="../Affine2/index.html#type-t">Affine2.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-affine3"><a href="#val-affine3" class="anchor"></a><code><span><span class="keyword">val</span> affine3 : <span><a href="../Affine3/index.html#type-t">Affine3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-quaternion"><a href="#val-quaternion" class="anchor"></a><code><span><span class="keyword">val</span> quaternion : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Quaternion/index.html#type-t">Quaternion.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_rotate"><a href="#val-axis_rotate" class="anchor"></a><code><span><span class="keyword">val</span> axis_rotate : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scale"><a href="#val-scale" class="anchor"></a><code><span><span class="keyword">val</span> scale : <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xscale"><a href="#val-xscale" class="anchor"></a><code><span><span class="keyword">val</span> xscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yscale"><a href="#val-yscale" class="anchor"></a><code><span><span class="keyword">val</span> yscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mirror"><a href="#val-mirror" class="anchor"></a><code><span><span class="keyword">val</span> mirror : <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div></div></body></html>