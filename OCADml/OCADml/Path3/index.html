<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Path3 (OCADml.OCADml.Path3)</title><link rel="stylesheet" href="../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">OCADml</a> &#x00BB; <a href="../index.html">OCADml</a> &#x00BB; Path3</nav><header class="odoc-preamble"><h1>Module <code><span>OCADml.Path3</span></code></h1><p>3d path generation (including arcs and basic shapes), manipulation (including roundovers (see <a href="Round/index.html"><code>Round</code></a>), and conversion to sweeping transformations with <a href="#val-to_transforms"><code>to_transforms</code></a>), and measurement.</p></header><nav class="odoc-toc"><ul><li><a href="#construction-/-conversion">Construction / Conversion</a></li><li><a href="#general-path-utilities">General Path Utilities</a></li><li><a href="#search">Search</a></li><li><a href="#creation-and-2d-3d-conversion">Creation and 2d-3d Conversion</a></li><li><a href="#basic-shapes">Basic Shapes</a></li><li><a href="#drawing-arcs">Drawing Arcs</a></li><li><a href="#roundovers">Roundovers</a></li><li><a href="#geometry">Geometry</a></li><li><a href="#sweeping-transform-helpers">Sweeping Transform Helpers</a></li><li><a href="#path-matching-/-vertex-association">Path Matching / Vertex Association</a></li><li><a href="#basic-transfomations">Basic Transfomations</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div></div><h2 id="construction-/-conversion"><a href="#construction-/-conversion" class="anchor"></a>Construction / Conversion</h2><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_list l</code></p><p>Construct a path from a list of points <code>l</code> (no-op).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><a href="../V3/index.html#type-t">V3.t</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_seq s</code></p><p>Construct a path from a sequence of points <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_array"><a href="#val-of_array" class="anchor"></a><code><span><span class="keyword">val</span> of_array : <span><span><a href="../V3/index.html#type-t">V3.t</a> array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_array a</code></p><p>Construct a path from an array of points <code>a</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>to_list t</code></p><p>Convert the path <code>t</code> to a list of points (no-op).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_seq t</code></p><p>Convert the path <code>t</code> to a sequence of points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_array"><a href="#val-to_array" class="anchor"></a><code><span><span class="keyword">val</span> to_array : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> array</span></span></code></div><div class="spec-doc"><p><code>to_array t</code></p><p>Convert the path <code>t</code> to a array of points.</p></div></div><h2 id="general-path-utilities"><a href="#general-path-utilities" class="anchor"></a>General Path Utilities</h2><div class="odoc-spec"><div class="spec value anchored" id="val-length"><a href="#val-length" class="anchor"></a><code><span><span class="keyword">val</span> length : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>length ?closed path</code></p><p>Calculate the length (total travel distance) of the <code>path</code>. If <code>closed</code> is <code>true</code>, include the distance between the endpoints (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cummulative_length"><a href="#val-cummulative_length" class="anchor"></a><code><span><span class="keyword">val</span> cummulative_length : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float list</span></span></code></div><div class="spec-doc"><p><code>cummulative_length ?closed path</code></p><p>Calculate the cummulative length (distance travelled by each point) along the <code>path</code>. If <code>closed</code> is <code>true</code>, include the distance between the endpoints (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_continuous"><a href="#val-to_continuous" class="anchor"></a><code><span><span class="keyword">val</span> to_continuous : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="../V3/index.html#type-t">V3.t</a></span></code></div><div class="spec-doc"><p><code>to_continuous path</code></p><p>Return a continuous function from values over the range of <code>0.</code> to <code>1.</code> to positions along <code>path</code> (like a bezier function), treated as open (<code>closed = false</code>) by default.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-resample"><a href="#val-resample" class="anchor"></a><code><span><span class="keyword">val</span> resample : <span>freq:<span>[&lt; <span>`N of int</span> <span><span>| `Spacing</span> of float</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>resample ~freq path</code></p><p>Resample <code>path</code> with the given <code>freq</code>uency (either a flat number of points, or a target point spacing). Note that the only points guaranteed to appear in the output are the start and end points of <code>path</code>. For upsampling that preserves input points, see <a href="#val-subdivide"><code>subdivide</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subdivide"><a href="#val-subdivide" class="anchor"></a><code><span><span class="keyword">val</span> subdivide : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>freq:
    <span>[ <span>`N of int * <span>[ `ByLen <span>| `BySeg</span> ]</span></span>
    <span><span>| `RoughN</span> of int * <span>[ `ByLen <span>| `BySeg</span> ]</span></span>
    <span><span>| `Refine</span> of int * <span>[ `ByLen <span>| `BySeg</span> ]</span></span>
    <span><span>| `RoughRefine</span> of int * <span>[ `ByLen <span>| `BySeg</span> ]</span></span>
    <span><span>| `Spacing</span> of float</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>subdivide ?closed ~freq path</code></p><p>Subdivides <code>path</code> with given <code>freq</code>uency, including each of the original points in the output (unlike <a href="#val-resample"><code>resample</code></a>). This can be a flat number of points provided directly with <code>`N (n, by)</code>, or as a multiple of number of points in <code>path</code> with <code>`Refine (factor, by)</code>. The strategy for distribution of points for these count based methods is set with the second parameter <code>by</code>, which can be either <code>`BySeg</code> (same number of additional points per segment) and <code>`ByLen</code> (segments gain new points proportional to their length). Alternatively, a maximum <code>`Spacing dist</code> can be specified instead. The <code>`Rough</code> point sampling variants will favour sampling uniformity, at the expense of not adhering exactly to the requested point count.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cut"><a href="#val-cut" class="anchor"></a><code><span><span class="keyword">val</span> cut : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>distances:<span>[ <span>`Abs of <span>float list</span></span> <span><span>| `Rel</span> of <span>float list</span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> list</span></span></code></div><div class="spec-doc"><p><code>cut ?closed ~distances path</code></p><p>Cut <code>path</code> at a list of increasing <code>distances</code> (<code>`Abs</code>olute or <code>`Rel</code>ative) along it from the start. If <code>closed</code> is <code>true</code>, the segment between the end and beginning of <code>path</code> will be considered, and the first point will be the last of the second path returned. Negative <code>`Abs distance</code> will start from the end to find the split point. Raises <code>Invalid_argument</code> if <code>distance</code> is an endpoint, or further than the end of the <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>distance:<span>[ <span>`Abs of float</span> <span><span>| `Rel</span> of float</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>split ?closed ~distance path</code></p><p>Split <code>path</code> into two at the position <code>distance</code> (<code>`Abs</code>olute or <code>`Rel</code>ative) along <code>path</code> from the start. Otherwise the behaviour is the same as <a href="#val-cut"><code>cut</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-noncollinear_triple"><a href="#val-noncollinear_triple" class="anchor"></a><code><span><span class="keyword">val</span> noncollinear_triple : 
  <span>?eps:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>(int * int * int)</span> * <span>(<a href="../V3/index.html#type-t">V3.t</a> * <a href="../V3/index.html#type-t">V3.t</a> * <a href="../V3/index.html#type-t">V3.t</a>)</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>noncollinear_triple ?eps path</code></p><p>Returns a pair of triples of non-collinear indices and the corresponding points from <code>path</code> (if the path is not completely collinear). Two well separated points are selected, and the third point is the furthest off the line drawn by the first two points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_collinear"><a href="#val-is_collinear" class="anchor"></a><code><span><span class="keyword">val</span> is_collinear : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_collinear ?eps path</code></p><p>Returns <code>true</code> if all points in <code>path</code> are collinear (fall within <code>eps</code> distance of the same line).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prune_collinear"><a href="#val-prune_collinear" class="anchor"></a><code><span><span class="keyword">val</span> prune_collinear : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>prune_collinear path</code></p><p>Remove collinear points from <code>path</code>. If <code>closed</code> is <code>true</code> the last point can be pruned as collinear with the first. The first point is never pruned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deduplicate_consecutive"><a href="#val-deduplicate_consecutive" class="anchor"></a><code><span><span class="keyword">val</span> deduplicate_consecutive : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?keep:<span>[ `First <span>| `Last</span> <span>| `FirstAndEnds</span> <span>| `LastAndEnds</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?eq:<span>(<span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>deduplicate_consecutive ?closed ?keep ?eq path</code></p><p>Remove consecutive duplicate points as determined by the (approximate) equality function <code>eq</code> (<code>V.approx ~eps:1e-9</code> by default) from <code>path</code>. By default <code>keep</code> is <code>`First</code>, which includes the first point of each run of duplicates in the output. This can be instead be set to <code>keep</code> the <code>`Last</code>, or to <code>`FirstAndEnds</code> or <code>`LastAndEnds</code>, which follow their respective simpler rules with the caveat of preserving the endpoints (first and last points) of the path. The path is treated as open (<code>closed = false</code>) by default, if <code>closed</code> is <code>true</code> the last point of the path may be dropped (even if <code>keep</code> is <code>`FirstAndEnds | `LastAndEnds</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deriv"><a href="#val-deriv" class="anchor"></a><code><span><span class="keyword">val</span> deriv : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span>?h:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>deriv ?closed ?h path</code></p><p>Computes a numerical derivative of <code>path</code>, with <code>h</code> (default <code>1.</code>) giving the step size of the sampling of <code>path</code>, so that the derivative can be scaled correctly. Setting <code>closed</code> to <code>true</code> will include computation of the derivative between the last and first point of the <code>path</code> (default <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-deriv_nonuniform"><a href="#val-deriv_nonuniform" class="anchor"></a><code><span><span class="keyword">val</span> deriv_nonuniform : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span>h:<span>float list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>deriv_nonuniform ?closed ?h path</code></p><p>Computes a numerical derivative of <code>path</code>, with <code>h</code> giving the non-uniform step sizes of the sampling of <code>path</code>, so that the derivative can be scaled correctly. Setting <code>closed</code> to <code>true</code> will include computation of the derivative between the last and first point of the <code>path</code> (default <code>false</code>). As <code>h</code> provides scaling factors for each segment of the path, it must have a length of one less than <code>path</code> if it's unclosed, and the same length if <code>closed</code> is <code>true</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tangents"><a href="#val-tangents" class="anchor"></a><code><span><span class="keyword">val</span> tangents : <span>?uniform:bool <span class="arrow">&#45;&gt;</span></span> <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>tangents ?uniform ?closed path</code></p><p>Compute tangent unit vectors of <code>path</code>. Set <code>closed</code> to <code>true</code> to indicate that tangents should include between the end and beginning of the path (default = <code>false</code>). Sampling of <code>path</code> is assumed to be <code>uniform</code> unless the parameter is set to <code>false</code>, in which case the derivatives will be adjusted to correct for non-uniform sampling of points.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-continuous_closest_point"><a href="#val-continuous_closest_point" class="anchor"></a><code><span><span class="keyword">val</span> continuous_closest_point : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?n_steps:int <span class="arrow">&#45;&gt;</span></span>
  <span>?max_err:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>float <span class="arrow">&#45;&gt;</span></span> <a href="../V3/index.html#type-t">V3.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  float</span></code></div><div class="spec-doc"><p><code>continuous_closest_point ?closed ?n_steps ?max_err f p</code></p><p>Find the closest position (from <code>0.</code> to <code>1.</code>) along the path function <code>f</code> to the point <code>p</code>.</p><ul><li><code>n_steps</code> sets the granularity of search at each stage.</li><li><code>max_err</code> the maximum distance the solution can be from the target <code>p</code></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-segment"><a href="#val-segment" class="anchor"></a><code><span><span class="keyword">val</span> segment : <span>?closed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-line">V3.line</a> list</span></span></code></div><div class="spec-doc"><p><code>segment ?closed path</code></p><p>Break <code>path</code> into line segments. If <code>closed</code> is <code>true</code>, include a segment between the last and first points of <code>path</code> (default <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reindex_polygon"><a href="#val-reindex_polygon" class="anchor"></a><code><span><span class="keyword">val</span> reindex_polygon : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>reindex_polygon reference poly</code></p><p>Rotate the polygonal (closed / coplanar) path <code>poly</code> to optimize its pairwise point association with the <code>reference</code> polygon. Paths should have the same clockwise winding direction (not checked / corrected).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lerp"><a href="#val-lerp" class="anchor"></a><code><span><span class="keyword">val</span> lerp : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>lerp a b u</code></p><p>Linearly interpolate between the paths <code>a</code> and <code>b</code>. Raises <code>Invalid_argument</code> if the paths are of unequal length.</p></div></div><h2 id="search"><a href="#search" class="anchor"></a>Search</h2><div class="odoc-spec"><div class="spec value anchored" id="val-nearby_idxs"><a href="#val-nearby_idxs" class="anchor"></a><code><span><span class="keyword">val</span> nearby_idxs : 
  <span>?min_tree_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>?radius:float <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int list</span></span></code></div><div class="spec-doc"><p><code>nearby_idxs ?min_tree_size ?radius path p</code></p><p>Find the indices of points within <code>radius</code> (default = <code>1e-9</code>) distance from the target point <code>p</code> in <code>path</code>. Match indices will be returned in arbitrary order (unsorted). When <code>path</code> is provided (eagerly on partial application), the length will be checked and a function to perform the search will be generated. If <code>path</code> is shorter than <code>min_tree_size</code>, it will be a simple direct search otherwise a <a href="../BallTree3/index.html#type-t"><code>BallTree3.t</code></a> will be constructed. Thus, if you plan to search for more than one target point, take care to apply this function in two steps to avoid repeated length checks and closure/tree generations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nearby_points"><a href="#val-nearby_points" class="anchor"></a><code><span><span class="keyword">val</span> nearby_points : 
  <span>?min_tree_size:int <span class="arrow">&#45;&gt;</span></span>
  <span>?radius:float <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>nearby_points ?min_tree_size ?radius path</code></p><p>Find the points within <code>radius</code> (default = <code>1e-9</code>) distance from the target point <code>p</code> in <code>path</code>. Matched points will be returned in arbitrary order (unsorted). When <code>path</code> is provided (eagerly on partial application), the length will be checked and a function to perform the search will be generated. If <code>path</code> is shorter than <code>min_tree_size</code>, it will be a simple direct search otherwise a <a href="../BallTree3/index.html#type-t"><code>BallTree3.t</code></a> will be constructed. Thus, if you plan to search for more than one target point, take care to apply this function in two steps to avoid repeated length checks and closure/tree generations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-closest_tangent"><a href="#val-closest_tangent" class="anchor"></a><code><span><span class="keyword">val</span> closest_tangent : 
  <span>?closed:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?offset:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>line:<a href="../V3/index.html#type-line">V3.line</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  int * <a href="../V3/index.html#type-line">V3.line</a></span></code></div><div class="spec-doc"><p><code>closest_tangent ?closed ?offset ~line t</code></p><p>Find the tangent segment (and its index) on the curved path <code>t</code> closest to <code>line</code> after <code>offset</code> (default = <code>V3.zero</code>) is applied to the points of <code>t</code> (can be used to centre the path relative to <code>line</code> to help in choosing the desired tangent).</p></div></div><h2 id="creation-and-2d-3d-conversion"><a href="#creation-and-2d-3d-conversion" class="anchor"></a>Creation and 2d-3d Conversion</h2><div class="odoc-spec"><div class="spec value anchored" id="val-of_tups"><a href="#val-of_tups" class="anchor"></a><code><span><span class="keyword">val</span> of_tups : <span><span><span>(float * float * float)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_tups ps</code></p><p>Create a 3d path from a list of xyz coordinate triples.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_path2"><a href="#val-of_path2" class="anchor"></a><code><span><span class="keyword">val</span> of_path2 : <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Path2/index.html#type-t">Path2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_path2 ?plane path</code></p><p>Lift a 2d <code>path</code> onto <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_path2"><a href="#val-to_path2" class="anchor"></a><code><span><span class="keyword">val</span> to_path2 : <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Path2/index.html#type-t">Path2.t</a></span></code></div><div class="spec-doc"><p><code>to_path2 ?plane t</code></p><p>Project the 3d path <code>t</code> onto <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_plane"><a href="#val-to_plane" class="anchor"></a><code><span><span class="keyword">val</span> to_plane : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Plane/index.html#type-t">Plane.t</a></span></code></div><div class="spec-doc"><p><code>to_plane ?eps t</code></p><p>Compute the normalized cartesian equation of the plane that the path <code>t</code> resides on. If there are fewer than three points in <code>t</code>, or they are not coplanar within the tolerance <code>eps</code>, an <code>Invalid_argument</code> exception is raised.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-project"><a href="#val-project" class="anchor"></a><code><span><span class="keyword">val</span> project : <span><a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Path2/index.html#type-t">Path2.t</a></span></code></div><div class="spec-doc"><p><code>project plane t</code></p><p>Project the 3d path <code>t</code> onto <code>plane</code>.</p></div></div><h2 id="basic-shapes"><a href="#basic-shapes" class="anchor"></a>Basic Shapes</h2><div class="odoc-spec"><div class="spec value anchored" id="val-circle"><a href="#val-circle" class="anchor"></a><code><span><span class="keyword">val</span> circle : <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>?fa:float <span class="arrow">&#45;&gt;</span></span> <span>?fs:float <span class="arrow">&#45;&gt;</span></span> <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>circle ?fn ?fa ?fs ?plane radius</code></p><p>Draw a circular path of radius <code>r</code> onto <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-square"><a href="#val-square" class="anchor"></a><code><span><span class="keyword">val</span> square : <span>?center:bool <span class="arrow">&#45;&gt;</span></span> <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>square ?center ?plane dims</code></p><p>Draw a rectangular path with xy <code>dims</code> (e.g. width and height) onto <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>). If <code>center</code> is <code>true</code> then the path will be centred around the origin (default = <code>false</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ellipse"><a href="#val-ellipse" class="anchor"></a><code><span><span class="keyword">val</span> ellipse : <span>?fn:int <span class="arrow">&#45;&gt;</span></span> <span>?fa:float <span class="arrow">&#45;&gt;</span></span> <span>?fs:float <span class="arrow">&#45;&gt;</span></span> <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>ellipse ?fn ?fa ?fs ?plane radii</code></p><p>Draw an ellipse with xy <code>radii</code> onto <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>). The greater of the two radii is used for fragment/resolution calculation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-star"><a href="#val-star" class="anchor"></a><code><span><span class="keyword">val</span> star : <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span> <span>r1:float <span class="arrow">&#45;&gt;</span></span> <span>r2:float <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>star ?plane ~r1 ~r2 n</code></p><p>Draw an <code>n</code> pointed star with inner radius <code>r1</code> and outer radius <code>r2</code> onto <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>).</p></div></div><h2 id="drawing-arcs"><a href="#drawing-arcs" class="anchor"></a>Drawing Arcs</h2><div class="odoc-spec"><div class="spec value anchored" id="val-arc"><a href="#val-arc" class="anchor"></a><code><span><span class="keyword">val</span> arc : 
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?plane:<a href="../Plane/index.html#type-t">Plane.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?wedge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>centre:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>radius:float <span class="arrow">&#45;&gt;</span></span>
  <span>start:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>arc ?rev ?fn ?fa ?fs ?plane ?wedge ~centre ~radius ~start a</code></p><p>Draw an arc onto a 3d <code>plane</code> (default = <a href="../Plane/index.html#val-xy"><code>Plane.xy</code></a>). See <a href="../Path2/index.html#val-arc"><code>Path2.arc</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-arc_about_centre"><a href="#val-arc_about_centre" class="anchor"></a><code><span><span class="keyword">val</span> arc_about_centre : 
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?dir:<span>[ `CW <span>| `CCW</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?wedge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>centre:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>arc_about_centre ?rev ?fn ?fa ?fs ?dir ?wedge ~centre p1 p2</code></p><p>Draw an arc between <code>p1</code> and <code>p2</code>, about <code>centre</code>, on the 3d plane occupied by the three points. See <a href="../Path2/index.html#val-arc_about_centre"><code>Path2.arc_about_centre</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-arc_through"><a href="#val-arc_through" class="anchor"></a><code><span><span class="keyword">val</span> arc_through : 
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?wedge:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>arc_through ?rev ?fn ?fa ?fs ?wedge p1 p2 p3</code></p><p>Draw an arc through the points <code>p1</code>, <code>p2</code>, and <code>p3</code>. See <a href="../Path2/index.html#val-arc_through"><code>Path2.arc_through</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-helix"><a href="#val-helix" class="anchor"></a><code><span><span class="keyword">val</span> helix : 
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?left:bool <span class="arrow">&#45;&gt;</span></span>
  <span>n_turns:int <span class="arrow">&#45;&gt;</span></span>
  <span>pitch:float <span class="arrow">&#45;&gt;</span></span>
  <span>?r2:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>helix ?fn ?fa ?fs ?left ~n_turns ~pitch ?r2 r1</code></p><p>Draw a 3d helical path around a cylinder/cone with start radius <code>r1</code> and end radius <code>r2</code> (default = <code>r1</code>).</p><ul><li><code>n_turns</code> sets the number of revolutions around the z-axis</li><li><code>pitch</code> describes the height of one complete turn</li><li><code>left</code> is used to set handedness (default = <code>true</code>)</li><li><code>fn</code>, <code>fa</code>, and <code>fs</code> parameters govern quality as they do in OpenSCAD</li></ul></div></div><h2 id="roundovers"><a href="#roundovers" class="anchor"></a>Roundovers</h2><p>Specification and application of circular, chamfer, and bezier (continuous curvature) roundovers to 3d paths.</p><p>Based on the <a href="https://github.com/revarbat/BOSL2">BOSL2</a> <a href="https://github.com/revarbat/BOSL2/blob/master/rounding.scad">rounding</a> module.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Round"><a href="#module-Round" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Round/index.html">Round</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Configuration module with types and helpers for specifying path roundovers.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-roundover"><a href="#val-roundover" class="anchor"></a><code><span><span class="keyword">val</span> roundover : 
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?overrun:<span>[ `Fail <span>| `Warn</span> <span>| `Fix</span> <span>| `NoCheck</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Round/index.html#type-t">Round.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>roundover ?fn ?fa ?fs ?overrun path_spec</code></p><p>Apply the roundover specifictions in <code>path_spec</code> on the bundled path/shape, with quality set by the <code>fn</code>, <code>fa</code>, and <code>fs</code> parameters. Collinear points are ignored (included in output without roundover applied).</p><p>When <code>overrun</code> is set to <code>`Fail</code> (as it is by default) this function will raise <code>Failure</code> if computed joint distances would lead to point insertion that causes the path to reverse/double back on itself. Alternatively:</p><ul><li><code>`Warn</code> will print the detected overruns to <code>stdout</code> rather than raising <code>Failure</code> (useful for debuggin)</li><li><code>`Fix</code> will automatically reduce the corner joints involved in each overrun proportional to their lengths.</li><li><code>`NoCheck</code> skips overrun detection</li></ul></div></div><h2 id="geometry"><a href="#geometry" class="anchor"></a>Geometry</h2><div class="odoc-spec"><div class="spec value anchored" id="val-normal"><a href="#val-normal" class="anchor"></a><code><span><span class="keyword">val</span> normal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../V3/index.html#type-t">V3.t</a></span></code></div><div class="spec-doc"><p><code>normal t</code></p><p>Calculate the normal vector of the path <code>t</code>. An <code>Invalid_argument</code> exception is raised if there are fewer than three points in <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-centroid"><a href="#val-centroid" class="anchor"></a><code><span><span class="keyword">val</span> centroid : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../V3/index.html#type-t">V3.t</a></span></code></div><div class="spec-doc"><p><code>centroid ?eps t</code></p><p>Compute the centroid of the path <code>t</code>. If <code>t</code> is collinear or self-intersecting (within <code>eps</code> tolerance), an <code>Invalid_argument</code> exception is raised.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-area"><a href="#val-area" class="anchor"></a><code><span><span class="keyword">val</span> area : <span>?signed:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>area ?signed t</code></p><p>Calculate the area of the co-planar path (describing a polygon) <code>t</code>. If <code>signed</code> is <code>true</code>, the signed area is returned.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-coplanar"><a href="#val-coplanar" class="anchor"></a><code><span><span class="keyword">val</span> coplanar : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>coplanar ?eps t</code></p><p>Returns <code>true</code> if all points in <code>t</code> are coplanar, within the tolerance <code>eps</code>. If there are fewer than 3 points, or the path is collinear, this returns <code>false</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bbox"><a href="#val-bbox" class="anchor"></a><code><span><span class="keyword">val</span> bbox : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Gg</span>.Box3.t</span></code></div><div class="spec-doc"><p><code>bbox t</code></p><p>Compute the 3d bounding box of the path <code>t</code>.</p></div></div><h2 id="sweeping-transform-helpers"><a href="#sweeping-transform-helpers" class="anchor"></a>Sweeping Transform Helpers</h2><div class="odoc-spec"><div class="spec value anchored" id="val-scaler"><a href="#val-scaler" class="anchor"></a><code><span><span class="keyword">val</span> scaler : <span>?ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="../Affine3/index.html#type-t">Affine3.t</a></span></code></div><div class="spec-doc"><p><code>scaler ?ez scale</code></p><p>Create a lookup from relative position (<code>0.</code> to <code>1.</code>) to scaling transformation matrix for interpolating from <code>{x = 1.; y = 1.}</code> at <code>0.</code> to <code>scale</code> by <code>1.</code>. If provided, the pair of handle points <code>ez</code> will be used to ease the scaling (see <a href="../Easing/index.html#val-make"><code>Easing.make</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-twister"><a href="#val-twister" class="anchor"></a><code><span><span class="keyword">val</span> twister : <span>?ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <a href="../Affine3/index.html#type-t">Affine3.t</a></span></code></div><div class="spec-doc"><p><code>twister ?ez angle</code></p><p>Create a lookup from relative position (<code>0.</code> to <code>1.</code>) to rotation transformation matrix for interpolating from <code>0.</code> (no rotation) at <code>0.</code> to <code>angle</code> by <code>1.</code>. If provided, the pair of handle points <code>ez</code> will be used to ease the scaling (see <a href="../Easing/index.html#val-make"><code>Easing.make</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_transforms"><a href="#val-to_transforms" class="anchor"></a><code><span><span class="keyword">val</span> to_transforms : 
  <span>?mode:<span>[ `Auto <span><span>| `Align</span> of <a href="../V3/index.html#type-t">V3.t</a></span> <span>| `NoAlign</span> <span>| `Euler</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Affine3/index.html#type-t">Affine3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>to_transforms ?mode ?scale_ez ?twist_ez ?scale ?twist t</code></p><p>Generate list of transformations that can be applied to three-dimensional vectors (<a href="../V3/index.html#type-t"><code>V3.t</code></a> via <a href="../Affine3/index.html#val-transform"><code>Affine3.transform</code></a>) or shapes, to move them along the path <code>t</code> (intended to be applied to the vector/shape from its original position each time). Note that the transforms are generated assuming the shape is centred on the origin, and for the purposes of alignment to the beginning of the path and scaling/twisting, laying flat on the XY plane.</p><p>When <code>mode</code> is <code>`Auto | `Align _ | `NoAlign</code> (default it <code>`Auto</code>), tangents are used to estimate appropriate rotations for each translation, using quaternion alignment from tangent to tangent, accumulating rotation along the way. In the case of <code>`Auto</code>, some effort is made to automatically apply an alignment rotation towards the first tangent of the path before each transformation such that the orientation of the shape being swept will be consistent and sensible, though some manual rotation of the shape before sweeping along the generated transforms may be necessary to get the desired result.</p><p><code>`Align v</code> and <code>`NoAlign</code> follow the same quaternion accumulation strategy along the path <code>t</code>, however they differ from <code>`Auto</code> in their handling of pre-alignment transformations. With <code>`Align v</code>, the vector <code>v</code> will be used to align the assumed shape normal of <code>(v3 0. 0. 1.)</code> to, while <code>`NoAlign</code> will skip the alignment step entirely (likely desirable if the intention is to sweep a shape <i>not</i> laying on the XY plane).</p><p>Setting <code>mode = `Euler</code> will use euler rotations instead, which can have results more in line with expectations in some scenarios (helical-like paths for example, though <a href="../Mesh/index.html#val-helix_extrude"><code>Mesh.helix_extrude</code></a> may be a better fit in that case), but fail in others. For instance, <code>`Euler</code> can generate an abrupt when the path tangent is exactly vertical.</p><p>If provided, <code>scale</code> and <code>twist</code>, specify scaling and rotation to be applied along the path increasing up to the provided value by the end. Scaling/twisting proceeds linearly by default, unless the corresponding <code>_ez</code> parameters are provided to describe the desired eased transition (see <a href="#val-scaler"><code>scaler</code></a> and <a href="#val-twister"><code>twister</code></a>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-helical_transforms"><a href="#val-helical_transforms" class="anchor"></a><code><span><span class="keyword">val</span> helical_transforms : 
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>?left:bool <span class="arrow">&#45;&gt;</span></span>
  <span>n_turns:int <span class="arrow">&#45;&gt;</span></span>
  <span>pitch:float <span class="arrow">&#45;&gt;</span></span>
  <span>?r2:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Affine3/index.html#type-t">Affine3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>helical_transforms ?fn ?fs ?fa ?scale_ez ?twist_ez ?scale ?twist
     ?left ~n_turns ~pitch ?r2 r1</code></p><p>Affine transformations following a helical path. This can be thought of like a special case of <a href="#val-to_transforms"><code>to_transforms</code></a>, but using a path generated with <a href="#val-helix"><code>helix</code></a>, and with rotational calculations taking into account the helical trajectory.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prune_transforms"><a href="#val-prune_transforms" class="anchor"></a><code><span><span class="keyword">val</span> prune_transforms : 
  <span>?min_dist:float <span class="arrow">&#45;&gt;</span></span>
  <span>shape:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Affine3/index.html#type-t">Affine3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int * <a href="../Affine3/index.html#type-t">Affine3.t</a>)</span> list</span></span></code></div><div class="spec-doc"><p><code>prune_transforms ?min_dist ~shape transforms</code></p><p>Filter <code>transforms</code> into <code>(idx, m)</code> pairs for which the polygon computed by applying <code>m</code> to the corresponding shape (result of <code>shape idx</code>, allowing for scaling operations etc) is at least <code>min_dist</code> (default <code>0.05</code>) above the plane of the previous polygon. This can be useful for avoiding self-intersections in the output of <a href="../Mesh/index.html#val-sweep"><code>Mesh.sweep</code></a>. Note that all polygons returned by <code>shape</code> must be planar, else <code>Failure</code> will be raised.</p></div></div><h2 id="path-matching-/-vertex-association"><a href="#path-matching-/-vertex-association" class="anchor"></a>Path Matching / Vertex Association</h2><p>Point duplicating strategies for associating vertices between incommensurate closed polygonal paths/profiles. Primarily for use in conjunction with <a href="../Mesh/index.html#val-skin"><code>Mesh.skin</code></a> and <a href="../Mesh/index.html#val-morphing_sweep"><code>Mesh.morphing_sweep</code></a>, where commensurate profiles are required to draw edges between.</p><p>Ported from the <a href="https://github.com/revarbat/BOSL2/blob/master/skin.scad">skin</a> module of the <a href="https://github.com/revarbat/BOSL2">BOSL2</a> OpenSCAD library.</p><div class="odoc-spec"><div class="spec value anchored" id="val-distance_match"><a href="#val-distance_match" class="anchor"></a><code><span><span class="keyword">val</span> distance_match : <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span> * <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>distance_match a b</code></p><p>If the closed polygonal paths <code>a</code> and <code>b</code> have incommensurate lengths, points on the smaller path are duplicated and the larger path is shifted (list rotated) in such a way that the total length of the edges between the associated vertices (same index/position) is minimized. The replacement paths, now having the same lengths, are returned as a pair (with the same order). This algorithm generally produces a good result when both <code>a</code> and <code>b</code> are discrete profiles with a small number of vertices.</p><p>This is computationally intensive ( <b>O(N<sup>3</sup>)</b> ), if the profiles are already known to be lined up, with their zeroth indices corresponding, then <a href="#val-aligned_distance_match"><code>aligned_distance_match</code></a> provides a ( <b>O(N<sup>2</sup>)</b> ) solution.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-aligned_distance_match"><a href="#val-aligned_distance_match" class="anchor"></a><code><span><span class="keyword">val</span> aligned_distance_match : <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span> * <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>aligned_distance_match a b</code></p><p>Like <a href="#val-distance_match"><code>distance_match</code></a>, but the paths <code>a</code> and <code>b</code> are assumed to already be &quot;lined up&quot;, with the zeroth indices in each corresponding to one another.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tangent_match"><a href="#val-tangent_match" class="anchor"></a><code><span><span class="keyword">val</span> tangent_match : <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span> * <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>tangent_match a b</code></p><p>If the closed polygonal paths <code>a</code> and <code>b</code> have incommensurate lengths, points on the larger (ideally convex, curved) path are grouped by association of their tangents with the edges of the smaller (ideally discrete) polygonal path. The points of the smaller path are then duplicated to associate with their corresponding spans of tangents on the curve, and the larger path is rotated to line up the indices. The profiles, now having the same length are returned as a pair in the order that they were applied returned.</p><p>This algorithm generally produces good results when connecting a discrete polygon to a <i>convex</i> finely sampled curve. It may fail if the curved profile is non-convex, or doesn't have enough points to distinguish all of the tangent points from each other.</p></div></div><h2 id="basic-transfomations"><a href="#basic-transfomations" class="anchor"></a>Basic Transfomations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-translate"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xtrans"><a href="#val-xtrans" class="anchor"></a><code><span><span class="keyword">val</span> xtrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ytrans"><a href="#val-ytrans" class="anchor"></a><code><span><span class="keyword">val</span> ytrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ztrans"><a href="#val-ztrans" class="anchor"></a><code><span><span class="keyword">val</span> ztrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rotate"><a href="#val-rotate" class="anchor"></a><code><span><span class="keyword">val</span> rotate : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xrot"><a href="#val-xrot" class="anchor"></a><code><span><span class="keyword">val</span> xrot : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yrot"><a href="#val-yrot" class="anchor"></a><code><span><span class="keyword">val</span> yrot : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zrot"><a href="#val-zrot" class="anchor"></a><code><span><span class="keyword">val</span> zrot : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-quaternion"><a href="#val-quaternion" class="anchor"></a><code><span><span class="keyword">val</span> quaternion : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Quaternion/index.html#type-t">Quaternion.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-axis_rotate"><a href="#val-axis_rotate" class="anchor"></a><code><span><span class="keyword">val</span> axis_rotate : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-affine"><a href="#val-affine" class="anchor"></a><code><span><span class="keyword">val</span> affine : <span><a href="../Affine3/index.html#type-t">Affine3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-scale"><a href="#val-scale" class="anchor"></a><code><span><span class="keyword">val</span> scale : <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-xscale"><a href="#val-xscale" class="anchor"></a><code><span><span class="keyword">val</span> xscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-yscale"><a href="#val-yscale" class="anchor"></a><code><span><span class="keyword">val</span> yscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-zscale"><a href="#val-zscale" class="anchor"></a><code><span><span class="keyword">val</span> zscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mirror"><a href="#val-mirror" class="anchor"></a><code><span><span class="keyword">val</span> mirror : <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div></div></body></html>