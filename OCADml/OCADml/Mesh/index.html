<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mesh (OCADml.OCADml.Mesh)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">OCADml</a> &#x00BB; <a href="../index.html">OCADml</a> &#x00BB; Mesh</nav><header class="odoc-preamble"><h1>Module <code><span>OCADml.Mesh</span></code></h1><p>Generation, and manipulation of 3-dimensional meshes (points and faces).</p><p>This data type and its constructors/transformers are based on the the <a href="https://github.com/revarbat/BOSL2/blob/master/vnf.scad">vnf structure module</a> of the <a href="https://github.com/revarbat/BOSL2/">BOSL2 OpenSCAD library</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#basic-constructors">Basic Constructors</a></li><li><a href="#accessors">Accessors</a></li><li><a href="#low-level-generators">Low-level Generators</a></li><li><a href="#skins">Skins</a></li><li><a href="#sweeps,-extrusions,-and-morphs-with-roundovers">Sweeps, extrusions, and morphs with roundovers</a><ul><li><a href="#fixed-polygon-sweeps-and-extrusions">Fixed polygon sweeps and extrusions</a></li><li><a href="#morphing-sweeps-and-extrusions">Morphing sweeps and extrusions</a></li></ul></li><li><a href="#generalized-prisms-with-continous-rounding">Generalized prisms with continous rounding</a></li><li><a href="#function-plotting">Function Plotting</a></li><li><a href="#mesh-utilities">Mesh Utilities</a></li><li><a href="#basic-transfomations">Basic Transfomations</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Points and faces 3-dimensional mesh.</p></div></div><h2 id="basic-constructors"><a href="#basic-constructors" class="anchor"></a>Basic Constructors</h2><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>An empty <code>t</code>, with no points.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>points:<span><a href="../V3/index.html#type-t">V3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>faces:<span><span>int list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make ~points ~faces</code></p><p>Create a mesh <code>t</code> from a list of <a href="../V3/index.html#type-t"><code>V3.t</code></a> <code>points</code>, and a list of <code>faces</code> described by indices into <code>points</code>.</p></div></div><h2 id="accessors"><a href="#accessors" class="anchor"></a>Accessors</h2><div class="odoc-spec"><div class="spec value" id="val-size" class="anchored"><a href="#val-size" class="anchor"></a><code><span><span class="keyword">val</span> size : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-points" class="anchored"><a href="#val-points" class="anchor"></a><code><span><span class="keyword">val</span> points : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> list</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-faces" class="anchored"><a href="#val-faces" class="anchor"></a><code><span><span class="keyword">val</span> faces : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>int list</span> list</span></span></code></div></div><h2 id="low-level-generators"><a href="#low-level-generators" class="anchor"></a>Low-level Generators</h2><div class="odoc-spec"><div class="spec type" id="type-endcaps" class="anchored"><a href="#type-endcaps" class="anchor"></a><code><span><span class="keyword">type</span> endcaps</span><span> = </span><span>[ </span></code><table><tr id="type-endcaps.Loop" class="anchored"><td class="def constructor"><a href="#type-endcaps.Loop" class="anchor"></a><code><span>| </span></code><code><span>`Loop</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Last/top row wrapped to the first/bottom</p><span class="comment-delim">*)</span></td></tr><tr id="type-endcaps.Both" class="anchored"><td class="def constructor"><a href="#type-endcaps.Both" class="anchor"></a><code><span>| </span></code><code><span>`Both</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Both bottom and top rows are closed with flat faces</p><span class="comment-delim">*)</span></td></tr><tr id="type-endcaps.None" class="anchored"><td class="def constructor"><a href="#type-endcaps.None" class="anchor"></a><code><span>| </span></code><code><span>`None</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Neither top or bottom rows are closed with a face</p><span class="comment-delim">*)</span></td></tr><tr id="type-endcaps.Top" class="anchored"><td class="def constructor"><a href="#type-endcaps.Top" class="anchor"></a><code><span>| </span></code><code><span>`Top</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A face is generated to close the top row with itself</p><span class="comment-delim">*)</span></td></tr><tr id="type-endcaps.Bot" class="anchored"><td class="def constructor"><a href="#type-endcaps.Bot" class="anchor"></a><code><span>| </span></code><code><span>`Bot</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A face is generated to close the bottom row with itself</p><span class="comment-delim">*)</span></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Describes desired row wrapping behaviour in <a href="#val-of_rows"><code>of_rows</code></a>, which creates a mesh from rows of points.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-style" class="anchored"><a href="#type-style" class="anchor"></a><code><span><span class="keyword">type</span> style</span><span> = </span><span>[ </span></code><table><tr id="type-style.Default" class="anchored"><td class="def constructor"><a href="#type-style.Default" class="anchor"></a><code><span>| </span></code><code><span>`Default</span></code></td></tr><tr id="type-style.Alt" class="anchored"><td class="def constructor"><a href="#type-style.Alt" class="anchor"></a><code><span>| </span></code><code><span>`Alt</span></code></td></tr><tr id="type-style.MinEdge" class="anchored"><td class="def constructor"><a href="#type-style.MinEdge" class="anchor"></a><code><span>| </span></code><code><span>`MinEdge</span></code></td></tr><tr id="type-style.Quincunx" class="anchored"><td class="def constructor"><a href="#type-style.Quincunx" class="anchor"></a><code><span>| </span></code><code><span>`Quincunx</span></code></td></tr><tr id="type-style.Convex" class="anchored"><td class="def constructor"><a href="#type-style.Convex" class="anchor"></a><code><span>| </span></code><code><span>`Convex</span></code></td></tr><tr id="type-style.Concave" class="anchored"><td class="def constructor"><a href="#type-style.Concave" class="anchor"></a><code><span>| </span></code><code><span>`Concave</span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Quadrilateral face triangulation strategy.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prune_rows" class="anchored"><a href="#val-prune_rows" class="anchor"></a><code><span><span class="keyword">val</span> prune_rows : <span>?min_dist:float <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Path3/index.html#type-t">Path3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>int list</span> * <span><a href="../Path3/index.html#type-t">Path3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>prune_rows ?min_dist rows</code></p><p>Filter <code>rows</code> such that each row polygon is at least <code>min_dist</code> (default <code>0.05</code>) above the plane of the previous polygon, indicating the dropped indices. This can be useful for avoiding self-intersections in the output of <a href="#val-of_rows"><code>of_rows</code></a>. Note that all polygons in <code>rows</code> must be planar, else <code>Failure</code> will be raised.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_rows" class="anchored"><a href="#val-of_rows" class="anchor"></a><code><span><span class="keyword">val</span> of_rows : 
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?endcaps:<a href="#type-endcaps">endcaps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?col_wrap:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_rows ?rev ?endcaps ?col_wrap ?style rows</code></p><p>Create a <a href="#type-t"><code>t</code></a> representing a polyhedron from a list of layers (counter_clockwise loops of 3d points). <code>endcaps</code> defaults to <code>`Both</code>, which specifies that faces should be generated to close off the bottom and top layers of the generated shape. If it is instead set to <code>`Loop</code>, the open faces of the first and last layers will be closed with one another. For more advanced usages, one or both of the endcaps can be left open, so the resulting meshes can be closed off by some other means.</p><ul><li><code>col_wrap</code> sets whether faces should be generated to loop between the ends of each row.</li><li>If <code>rev</code> is <code>true</code>, faces winding direction will be reversed (default = <code>false</code>)</li><li><p><code>style</code> governs how the quadrilaterals formed by the rows and columns of points are divided into triangles:</p><ul><li><code>`Default</code> is an arbitrary systematic subdivision in the same direction</li><li><code>`Alt</code> is the uniform subdivision in the other (alternate direction)</li><li><code>`MinEdge</code> picks the shorter edge to subdivide the quadrilateral, so the division may not be uniform across the shape</li><li><code>`Quincunx</code> adds a vertex in the middle of each quadrilateral and creates four triangles</li><li><code>`Convex</code> and <code>`Concave</code> choose the locally convex/concave subdivision</li></ul></li><li>If <code>rows</code> is empty, a <a href="#val-empty"><code>empty</code></a> is returned. Throws <code>Invalid_argument</code> if <code>rows</code> contains only one row, or if it is not rectangular (any row differs in length).</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_ragged" class="anchored"><a href="#val-of_ragged" class="anchor"></a><code><span><span class="keyword">val</span> of_ragged : <span>?looped:bool <span class="arrow">&#45;&gt;</span></span> <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="../V3/index.html#type-t">V3.t</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_ragged ?looped ?reverse rows</code></p><p>Create a triangular mesh from a list of rows, where each row can differ in length relative to its neighbours by up to 2. Since the rows can be ragged, no (columnar) wrapping is done, thus they are best described as rows, rather than layers as with <a href="#val-of_rows"><code>of_rows</code></a> which produces an enclosed polyhedron. Instead, this function is useful for the generation of triangular patches that can be joined with one another to create a complete polyhedron. Setting <code>looped</code> to true will generate faces between the last and first rows, so long as their lengths differ by no more than 2. Face winding order is reversed if <code>reverse</code> is <code>true</code>. Throws <code>Invalid_argument</code> if a row length delta of greater than 2 is encountered.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_path2" class="anchored"><a href="#val-of_path2" class="anchor"></a><code><span><span class="keyword">val</span> of_path2 : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Path2/index.html#type-t">Path2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_path3 ?rev layer</code></p><p>Create a mesh from a single path (a closed loop of <a href="../V2/index.html#type-t"><code>V2.t</code></a>), returning a <a href="#type-t"><code>t</code></a> with a single face including all of the points. Face winding order is reversed if <code>rev</code> is <code>true</code>. This can be useful for producing a flat patch mesh to be combined with other meshes to produce a complete shape.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_path3" class="anchored"><a href="#val-of_path3" class="anchor"></a><code><span><span class="keyword">val</span> of_path3 : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Path3/index.html#type-t">Path3.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_path3 ?rev layer</code></p><p>Create a mesh from a single path (a closed loop of <a href="../V3/index.html#type-t"><code>V3.t</code></a>, should be coplanar though it is not confirmed), returning a <a href="#type-t"><code>t</code></a> with a single face including all of the points. Face winding order is reversed if <code>rev</code> is <code>true</code>. This can be useful for producing a flat patch mesh to be combined with other meshes to produce a complete shape.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_poly2" class="anchored"><a href="#val-of_poly2" class="anchor"></a><code><span><span class="keyword">val</span> of_poly2 : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_poly2 ?rev poly</code></p><p>Create a mesh from a 2d polygon. If <code>poly</code> does not have any holes, then this is equivalent to <a href="#val-of_path2"><code>of_path2</code></a>. If there are holes, polyhole partitioning is performed to determine a set of faces that can close the points.</p><p>The earcutting algorithm used to partition the polygon into faces is a port of RonaldoCMP's work found <a href="https://github.com/RonaldoCMP/Polygon-stuffs/blob/master/polyHolePartition.scad">here</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_poly3" class="anchored"><a href="#val-of_poly3" class="anchor"></a><code><span><span class="keyword">val</span> of_poly3 : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Poly3/index.html#type-t">Poly3.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_poly3 ?rev poly</code></p><p>Create a mesh from a 3d polygon. If <code>poly</code> does not have any holes, then this is equivalent to <a href="#val-of_path3"><code>of_path3</code></a>. If there are holes, polyhole partitioning is performed to determine a set of faces that can close the points.</p><p>The earcutting algorithm used to partition the polygon into faces is a port of RonaldoCMP's work found <a href="https://github.com/RonaldoCMP/Polygon-stuffs/blob/master/polyHolePartition.scad">here</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_polygons" class="anchored"><a href="#val-of_polygons" class="anchor"></a><code><span><span class="keyword">val</span> of_polygons : <span><span><a href="../Path3/index.html#type-t">Path3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_polygons polys</code></p><p>Create a polyhedron mesh from a list of polygonal point faces.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hull" class="anchored"><a href="#val-hull" class="anchor"></a><code><span><span class="keyword">val</span> hull : <span><a href="../Path3/index.html#type-t">Path3.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>hull points</code></p><p>Create a convex hull mesh that encloses <code>points</code>. If the points are coplanar, a 2-dimensional hull is found, resulting in an unclosed single face mesh (as with <a href="#val-of_path3"><code>of_path3</code></a>). Unused points are not discarded.</p></div></div><h2 id="skins"><a href="#skins" class="anchor"></a>Skins</h2><p>Functions for generating meshes which cover over a sequence of closed polygonal <a href="../Path3/index.html#type-t"><code>Path3.t</code></a> profiles. Ported from the <a href="https://github.com/revarbat/BOSL2/blob/master/skin.scad">skin</a> module of the <a href="https://github.com/revarbat/BOSL2">BOSL2</a> OpenSCAD library.</p><div class="odoc-spec"><div class="spec type" id="type-resampler" class="anchored"><a href="#type-resampler" class="anchor"></a><code><span><span class="keyword">type</span> resampler</span><span> = </span><span>[ </span></code><table><tr id="type-resampler.Direct" class="anchored"><td class="def constructor"><a href="#type-resampler.Direct" class="anchor"></a><code><span>| </span></code><code><span>`Direct <span class="keyword">of</span> <span>[ `ByLen <span>| `BySeg</span> ]</span></span></code></td></tr><tr id="type-resampler.Reindex" class="anchored"><td class="def constructor"><a href="#type-resampler.Reindex" class="anchor"></a><code><span>| </span></code><code><span>`Reindex <span class="keyword">of</span> <span>[ `ByLen <span>| `BySeg</span> ]</span></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Path resampling vertex mapping strategies.</p><p>Each of these variants specify that profiles of incommensurate length should simply resampled with <a href="../Path3/index.html#val-subdivide"><code>Path3.subdivide</code></a> with the provided point distribution frequency strategy (<code>[`ByLen | `BySeg]</code>). In the case of <code>`Direct _</code>, the profiles are assumed to be &quot;lined up&quot;, with the points at their zeroth indices corresponding to eachother. The <code>`Reindex _</code> strategy will rotate the second profile of a pair via <a href="../Path3/index.html#val-reindex_polygon"><code>Path3.reindex_polygon</code></a> following resampling to minimize the distance between the zeroth indices of the two paths.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-duplicator" class="anchored"><a href="#type-duplicator" class="anchor"></a><code><span><span class="keyword">type</span> duplicator</span><span> = </span><span>[ </span></code><table><tr id="type-duplicator.Distance" class="anchored"><td class="def constructor"><a href="#type-duplicator.Distance" class="anchor"></a><code><span>| </span></code><code><span>`Distance</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Minimize the length of the edges between associated vertices. Best results when connecting discrete polygon profiles with low point counts.</p><span class="comment-delim">*)</span></td></tr><tr id="type-duplicator.FastDistance" class="anchored"><td class="def constructor"><a href="#type-duplicator.FastDistance" class="anchor"></a><code><span>| </span></code><code><span>`FastDistance</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Like <code>`Distance</code>, but profiles are assumed to already be lined up, with their zeroth indices corresponding to one another.</p><span class="comment-delim">*)</span></td></tr><tr id="type-duplicator.Tangent" class="anchored"><td class="def constructor"><a href="#type-duplicator.Tangent" class="anchor"></a><code><span>| </span></code><code><span>`Tangent</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Split finely sampled (convex) curve into groups of points, and map each group to point on the smaller discrete polygon. Can fail if the larger curved path is non-convex, or does not have enough points.</p><span class="comment-delim">*)</span></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Point duplicating vertex mapping strategies.</p><p>Each of these variants specify profiles of incommensurate length should be matched up by computing vertex mappings between the profiles, and duplicating vertices on the smaller/shorter profile until the point counts are equalized. See the conspicuously named vertex matching functions <a href="../Path3/index.html#val-distance_match"><code>Path3.distance_match</code></a>, <a href="../Path3/index.html#val-aligned_distance_match"><code>Path3.aligned_distance_match</code></a>, and <a href="../Path3/index.html#val-tangent_match"><code>Path3.tangent_match</code></a> for more details (also available in the <a href="../Path2/index.html"><code>Path2</code></a> module).</p></div></div><div class="odoc-spec"><div class="spec type" id="type-mapping" class="anchored"><a href="#type-mapping" class="anchor"></a><code><span><span class="keyword">type</span> mapping</span><span> = </span><span>[ </span></code><table><tr id="type-mapping.resampler" class="anchored"><td class="def type"><a href="#type-mapping.resampler" class="anchor"></a><code><span>| </span></code><code><span><a href="#type-resampler">resampler</a></span></code></td></tr><tr id="type-mapping.duplicator" class="anchored"><td class="def type"><a href="#type-mapping.duplicator" class="anchor"></a><code><span>| </span></code><code><span><a href="#type-duplicator">duplicator</a></span></code></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Vertex count matching strategy specification type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-slice_profiles" class="anchored"><a href="#val-slice_profiles" class="anchor"></a><code><span><span class="keyword">val</span> slice_profiles : 
  <span>?looped:bool <span class="arrow">&#45;&gt;</span></span>
  <span>slices:<span>[&lt; <span>`Flat of int</span> <span><span>| `Mix</span> of <span>int list</span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Path3/index.html#type-t">Path3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Path3/index.html#type-t">Path3.t</a> list</span></span></code></div><div class="spec-doc"><p><code>slice_profiles ?looped ~slices profiles</code></p><p>Linearly transition between each neighbouring pair of closed paths in <code>profiles</code> to produce new interpolated list of profiles. The number of <code>slices</code> inserted between can either be the same between each pair (<code>`Flat n</code>), or specified separately with <code>`Mix ns</code>. If <code>looped</code> is <code>true</code>, then slices will also be inserted between the last and initial profiles (default is <code>false</code>). Lists of profiles such as these can be used to produce meshes with <a href="#val-of_rows"><code>of_rows</code></a> (as <a href="#val-skin"><code>skin</code></a> does).</p><p>Raises <code>Invalid_argument</code> if the length of <code>`Mix ns</code> does not correspond to the number of transitions, or if <code>profiles</code> has fewer than two elements.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-skin" class="anchored"><a href="#val-skin" class="anchor"></a><code><span><span class="keyword">val</span> skin : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?endcaps:<a href="#type-endcaps">endcaps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?refine:int <span class="arrow">&#45;&gt;</span></span>
  <span>?mapping:<span>[ <span>`Flat of <a href="#type-mapping">mapping</a></span> <span><span>| `Mix</span> of <span><a href="#type-mapping">mapping</a> list</span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>slices:<span>[&lt; <span>`Flat of int</span> <span><span>| `Mix</span> of <span>int list</span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Path3/index.html#type-t">Path3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>skin ?style ?endcaps ?refine ?mapping ~slices profiles</code></p><p>Produce a mesh that skins over two or more 3d <code>profiles</code> -- closed, ideally coplanar (though some slight variation can be ok) paths. This works by linearly interpolating between neighbouring profiles with <code>slices</code> steps, and passing the profiles along to <a href="#val-of_rows"><code>of_rows</code></a>, which generates faces to enclose the shape. For this to be well defined, each row must have the same length, thus <code>mapping</code> can be used to specify the strategy used to map/associate the vertices between them and reconcile the point counts and improve alignment for their connecting edges (see <a href="#type-resampler"><code>resampler</code></a> and <a href="#type-duplicator"><code>duplicator</code></a> configuration variants). By default this is <code>`Direct</code>, which simply applies resampling without altering the vertex associations established by the start indices of each profile.</p><ul><li><code>refine</code> can be specified to apply additional upsampling which may help to improve the smoothness of the resulting mesh. Uses <a href="../Path3/index.html#val-subdivide"><code>Path3.subdivide</code></a> with the sampling frequency indicated for <a href="#type-resampler"><code>resampler</code></a> mapped transitions, and <code>`BySeg</code> for <a href="#type-duplicator"><code>duplicator</code></a>s.</li><li><code>slices</code> and <code>mapping</code> can be provided as <code>`Flat _</code> to be applied to all transitions, or as <code>`Mix l</code>, where <code>l</code> is a list with length equal to the number of profile transitions (<code>length profiles - 1</code>, or <code>length profiles</code> if <code>endcaps</code> is <code>`Loop</code>)</li><li><b>NOTE:</b> mixing mapping strategies can be fickle, and some combinations may not work depending on the profiles. This may improve as kinks are worked out, but maybe not</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-skin_between" class="anchored"><a href="#val-skin_between" class="anchor"></a><code><span><span class="keyword">val</span> skin_between : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?endcaps:<span>[ `Both <span>| `None</span> <span>| `Top</span> <span>| `Bot</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?refine:int <span class="arrow">&#45;&gt;</span></span>
  <span>?mapping:<a href="#type-mapping">mapping</a> <span class="arrow">&#45;&gt;</span></span>
  <span>slices:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Path3/index.html#type-t">Path3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Path3/index.html#type-t">Path3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>skin_between ?style ?endcaps ?refine ?mapping ~slices a b</code></p><p>Create a mesh that <i>skins</i> over a linear interpolation/morph between 3d profiles <code>a</code> and <code>b</code> over <code>slices</code> steps. See <a href="#val-skin"><code>skin</code></a> for more details.</p></div></div><h2 id="sweeps,-extrusions,-and-morphs-with-roundovers"><a href="#sweeps,-extrusions,-and-morphs-with-roundovers" class="anchor"></a>Sweeps, extrusions, and morphs with roundovers</h2><p>Sweeps, extrusions and morphs from 2d to 3d. Each of which can be given rounded over end caps via their optional <code>?caps</code> parameters with specifications contsructed by the <a href="Cap/index.html"><code>Cap</code></a> module. and the optional <code>?caps</code>. Roundovers are based on the implementations found in the <a href="https://github.com/revarbat/BOSL2">BOSL2</a> library's <code>offset_sweep</code> functions from the <a href="https://github.com/revarbat/BOSL2/blob/master/rounding.scad">rounding</a> module.</p><div class="odoc-spec"><div class="spec module" id="module-Cap" class="anchored"><a href="#module-Cap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cap/index.html">Cap</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Configuration module for declaring how extrusions from 2d to 3d via <a href="#val-sweep"><code>sweep</code></a> should be capped off.</p></div></div><h3 id="fixed-polygon-sweeps-and-extrusions"><a href="#fixed-polygon-sweeps-and-extrusions" class="anchor"></a>Fixed polygon sweeps and extrusions</h3><div class="odoc-spec"><div class="spec value" id="val-sweep" class="anchored"><a href="#val-sweep" class="anchor"></a><code><span><span class="keyword">val</span> sweep : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW CW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-t">Cap.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>transforms:<span><a href="../Affine3/index.html#type-t">Affine3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sweep ?check_valid ?style ?winding ?merge ?fn ?fs ?fa ?caps ~transforms poly</code></p><p>Sweep a 2d polygon into a 3d mesh by applying a sequence of <code>transforms</code> to the original shape. The <code>winding</code> parameter can be used to set automatic enforcement of polygon winding direction, which will impact the winding of the generated faces of the mesh. What is done with the endcaps can be specified with <code>caps</code>. By default the ends of the extrusion are sealed with flat faces, but they can instead be looped to eachother, left empty, or rounded over. If <code>style</code> is provided, it will be passed along to <a href="#val-of_rows"><code>of_rows</code></a>, which handles converting the swept shapes into a mesh.</p><p>If <code>merge</code> is <code>true</code> (as is default), <a href="#val-merge_points"><code>merge_points</code></a> is applied to the resulting mesh, as duplicate points are introduced when end caps are joined to the outer and inner meshes. If the duplicate points aren't a problem for you (they aren't <i>necessarily</i>), this can be turned off to save some compute.</p><p><code>check_valid</code> determines whether validity checks are performed during offset operations (see <a href="../Path2/index.html#val-offset"><code>Path2.offset</code></a>), for cap roundovers (if specified). Additionally, unless <code>check_valid</code> is <code>`No</code>, polygon validation will be performed with final outer and inner paths of the caps before their mesh is generated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-extrude" class="anchored"><a href="#val-extrude" class="anchor"></a><code><span><span class="keyword">val</span> extrude : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW CW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?slices:int <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>?center:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-caps">Cap.caps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>height:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>extrude ~height poly</code></p><p>Vertically extrude a 2d polygon from the XY plane to <code>height</code>. If <code>?center</code> is true, the resulting 3D object is centered around the XY plane, rather than resting on top of it.</p><ul><li><code>?twist</code> rotates the shape by the specified angle as it is extruded upwards</li><li><code>?slices</code> specifies the number of intermediate points along the Z axis of the extrusion. By default this increases with the value of <code>?twist</code>, though manual refinement my improve results.</li><li><code>?scale</code> expands or contracts the shape in X and Y as it is extruded upward. Default is <code>(v2 1. 1.)</code>, no scaling.</li><li>Scaling/twisting proceed linearly by default, though bezier easing can be specified by providing handle points to the <code>scale_ez</code> and <code>twist_ez</code> parameter respectively. (see <a href="../Path3/index.html#val-scaler"><code>Path3.scaler</code></a> and <a href="../Path3/index.html#val-twister"><code>Path3.twister</code></a>).</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-path_extrude" class="anchored"><a href="#val-path_extrude" class="anchor"></a><code><span><span class="keyword">val</span> path_extrude : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW CW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-t">Cap.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?euler:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>path:<a href="../Path3/index.html#type-t">Path3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>path_extrude ?check_valid ?style ?merge ?winding ?caps ?euler
     ?scale_ez ?twist_ez ?scale ?twist ~path poly</code></p><p>Extrude a 2d polygon along the given <code>path</code> into a 3d mesh. This is a convenience function that composes transform generation using <a href="../Path3/index.html#val-to_transforms"><code>Path3.to_transforms</code></a> with <a href="#val-sweep"><code>sweep</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-helix_extrude" class="anchored"><a href="#val-helix_extrude" class="anchor"></a><code><span><span class="keyword">val</span> helix_extrude : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-caps">Cap.caps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?left:bool <span class="arrow">&#45;&gt;</span></span>
  <span>n_turns:int <span class="arrow">&#45;&gt;</span></span>
  <span>pitch:float <span class="arrow">&#45;&gt;</span></span>
  <span>?r2:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>helix_extrude ?check_valid ?style ?merge ?fn ?fs ?fa ?scale_ez ?twist_ez ?scale ?twist
     ?caps ?left ~n_turns ~pitch ?r2 r1 poly</code></p><p>Helical extrusion of a 2d polygon into a 3d mesh. This is a special case of <a href="#val-path_extrude"><code>path_extrude</code></a>, but following a path generated with <a href="../Path3/index.html#val-helix"><code>Path3.helix</code></a>, and using transforms that take the helical rotation into account.</p></div></div><h3 id="morphing-sweeps-and-extrusions"><a href="#morphing-sweeps-and-extrusions" class="anchor"></a>Morphing sweeps and extrusions</h3><p>These functions serve as the morphing counterparts of the fixed polygon sweeping functions above. In contrast to the more general <a href="#val-skin"><code>skin</code></a> which transitions between 3d <a href="../Path3/index.html#type-t"><code>Path3.t</code></a> profiles in sequence, these restrict the bounding shapes to 2d, and lift to 3d via the provided transforms, or path specifications. This separation of the morphing transition and spatial transformations allows for the easy addition of non-linear <a href="../Easing/index.html"><code>Easing</code></a> between the shapes via the <code>?ez</code> parameters (default is linear transition along the spatial distance covered by the sweep beginning from its origin).</p><div class="odoc-spec"><div class="spec value" id="val-morphing_sweep" class="anchored"><a href="#val-morphing_sweep" class="anchor"></a><code><span><span class="keyword">val</span> morphing_sweep : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW CW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-caps">Cap.caps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?outer_map:<a href="#type-mapping">mapping</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?hole_map:<span>[ `Same <span><span>| `Flat</span> of <a href="#type-mapping">mapping</a></span> <span><span>| `Mix</span> of <span><a href="#type-mapping">mapping</a> list</span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?refine:int <span class="arrow">&#45;&gt;</span></span>
  <span>?ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>transforms:<span><a href="../Affine3/index.html#type-t">Affine3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>morphing_sweep ~transforms a b</code></p><p>Morph between the polygons <code>a</code> and <code>b</code> while sweeping the hybrids along <code>transforms</code> to create a mesh. The <code>outer_map</code>, <code>hole_map</code>, and <code>refine</code> correspond to the the similarly named parameters of the more general <a href="#val-skin"><code>skin</code></a>, while the optional <code>ez</code> parameter allows the transition to be bezier eased via <a href="../Easing/index.html#val-make"><code>Easing.make</code></a>, rather than strictly linearly. See <a href="#val-sweep"><code>sweep</code></a> for details on the remaining common parameters.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-morph" class="anchored"><a href="#val-morph" class="anchor"></a><code><span><span class="keyword">val</span> morph : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?slices:int <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>?center:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-caps">Cap.caps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?outer_map:<a href="#type-mapping">mapping</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?hole_map:<span>[ <span>`Flat of <a href="#type-mapping">mapping</a></span> <span><span>| `Mix</span> of <span><a href="#type-mapping">mapping</a> list</span></span> <span>| `Same</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?refine:int <span class="arrow">&#45;&gt;</span></span>
  <span>?ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>height:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>morph ~height a b</code></p><p>Vertically morph between the 2d polygons <code>a</code> and <code>b</code>. This function is to <a href="#val-morphing_sweep"><code>morphing_sweep</code></a>, as <a href="#val-extrude"><code>extrude</code></a> is to <a href="#val-sweep"><code>sweep</code></a>. See each of the former for details on their common parameters.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-path_morph" class="anchored"><a href="#val-path_morph" class="anchor"></a><code><span><span class="keyword">val</span> path_morph : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW CW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-caps">Cap.caps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?outer_map:<a href="#type-mapping">mapping</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?hole_map:<span>[ <span>`Flat of <a href="#type-mapping">mapping</a></span> <span><span>| `Mix</span> of <span><a href="#type-mapping">mapping</a> list</span></span> <span>| `Same</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?refine:int <span class="arrow">&#45;&gt;</span></span>
  <span>?ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?euler:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>path:<a href="../Path3/index.html#type-t">Path3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>path_morph ~path poly</code></p><p>Morph between the 2d polygons <code>a</code> and <code>b</code> along the given <code>path</code>. This is a convenience function that composes transform generation using <a href="../Path3/index.html#val-to_transforms"><code>Path3.to_transforms</code></a> with <a href="#val-morphing_sweep"><code>morphing_sweep</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-helix_morph" class="anchored"><a href="#val-helix_morph" class="anchor"></a><code><span><span class="keyword">val</span> helix_morph : 
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../V2/index.html#type-t">V2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-caps">Cap.caps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?outer_map:<a href="#type-mapping">mapping</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?hole_map:<span>[ <span>`Flat of <a href="#type-mapping">mapping</a></span> <span><span>| `Mix</span> of <span><a href="#type-mapping">mapping</a> list</span></span> <span>| `Same</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?refine:int <span class="arrow">&#45;&gt;</span></span>
  <span>?ez:<span>(<a href="../V2/index.html#type-t">V2.t</a> * <a href="../V2/index.html#type-t">V2.t</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?left:bool <span class="arrow">&#45;&gt;</span></span>
  <span>n_turns:int <span class="arrow">&#45;&gt;</span></span>
  <span>pitch:float <span class="arrow">&#45;&gt;</span></span>
  <span>?r2:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>helix_morph ~n_turns ~pitch ?r2 r1 a b</code></p><p>Morph between the 2d polygons <code>a</code> and <code>b</code> along a helical path. This is a special case of <a href="#val-path_morph"><code>path_morph</code></a>, but following a path generated with <a href="../Path3/index.html#val-helix"><code>Path3.helix</code></a>, and using transforms that take the helical rotation into account.</p></div></div><h2 id="generalized-prisms-with-continous-rounding"><a href="#generalized-prisms-with-continous-rounding" class="anchor"></a>Generalized prisms with continous rounding</h2><div class="odoc-spec"><div class="spec module" id="module-Prism" class="anchored"><a href="#module-Prism" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Prism/index.html">Prism</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Rounded prism configuration module.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prism" class="anchored"><a href="#val-prism" class="anchor"></a><code><span><span class="keyword">val</span> prism : 
  <span>?debug:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?holes:<a href="Prism/index.html#type-holes">Prism.holes</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?outer:<a href="Prism/index.html#type-spec">Prism.spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly3/index.html#type-t">Poly3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly3/index.html#type-t">Poly3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>prism ?debug ?fn ?holes ?outer bottom top</code></p><p>Create a prism with continuous curvature rounding from the given <code>bottom</code> and <code>top</code> polygons. The edges running between the corresponding paths must produce a valid polyhedron with coplanar side faces, thus the top should generally be the same shape as the bottom translated/transformed in such a way as to not violate this assumption (avoid z-rotation for one). Roundover specifications are provided with <code>outer</code> and <code>holes</code> (see <a href="Prism/index.html#type-spec"><code>Prism.spec</code></a> and <a href="Prism/index.html#type-holes"><code>Prism.holes</code></a> for details).</p><ul><li><code>debug</code> can be set to <code>true</code> to skip validity checks that would otherwise raise exceptions on failure, so a mesh can still be obtained for inspection.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-linear_prism" class="anchored"><a href="#val-linear_prism" class="anchor"></a><code><span><span class="keyword">val</span> linear_prism : 
  <span>?debug:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?holes:<a href="Prism/index.html#type-holes">Prism.holes</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?outer:<a href="Prism/index.html#type-spec">Prism.spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?center:bool <span class="arrow">&#45;&gt;</span></span>
  <span>height:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>linear_prism ?debug ?fn ?holes ?outer ?center ~height bottom</code></p><p>Create a prism with continuous curvature rounding by extruding the polygon <code>bottom</code> linearaly upward to the given <code>height</code>. If <code>center</code> is <code>true</code>, the resulting prism will be centred in z around the xy plane. See the more general case <a href="#val-prism"><code>prism</code></a> for more details.</p></div></div><h2 id="function-plotting"><a href="#function-plotting" class="anchor"></a>Function Plotting</h2><p>Ported from the <a href="https://github.com/rcolyer/plot-function">PlotFunction</a> library by Ryan Colyer.</p><div class="odoc-spec"><div class="spec value" id="val-cartesian_plot" class="anchored"><a href="#val-cartesian_plot" class="anchor"></a><code><span><span class="keyword">val</span> cartesian_plot : 
  <span>min_x:float <span class="arrow">&#45;&gt;</span></span>
  <span>x_steps:int <span class="arrow">&#45;&gt;</span></span>
  <span>max_x:float <span class="arrow">&#45;&gt;</span></span>
  <span>min_y:float <span class="arrow">&#45;&gt;</span></span>
  <span>y_steps:int <span class="arrow">&#45;&gt;</span></span>
  <span>max_y:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>x:float <span class="arrow">&#45;&gt;</span></span> <span>y:float <span class="arrow">&#45;&gt;</span></span> float )</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>cartesian_plot ~min_x ~x_steps ~max_x ~min_y ~y_steps ~max_y f</code></p><p>Create a mesh of the function <code>f</code> (from x and y to z) over the ranges of x and y defined by the rest of the parameters.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-polar_plot" class="anchored"><a href="#val-polar_plot" class="anchor"></a><code><span><span class="keyword">val</span> polar_plot : 
  <span>?r_step:float <span class="arrow">&#45;&gt;</span></span>
  <span>max_r:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>r:float <span class="arrow">&#45;&gt;</span></span> <span>a:float <span class="arrow">&#45;&gt;</span></span> float )</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>polar_plot ?r_step ~max_r f</code></p><p>Create a mesh of the function <code>f</code> (from radius and angle to z) between the z-axis and the radius <code>max_r</code>, with the minimum radial step <code>r_step</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-axial_plot" class="anchored"><a href="#val-axial_plot" class="anchor"></a><code><span><span class="keyword">val</span> axial_plot : 
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>min_z:float <span class="arrow">&#45;&gt;</span></span>
  <span>z_steps:int <span class="arrow">&#45;&gt;</span></span>
  <span>max_z:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>z:float <span class="arrow">&#45;&gt;</span></span> <span>a:float <span class="arrow">&#45;&gt;</span></span> float )</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>axial_plot ?fn ~min_z ~z_step ~max_z f</code></p><p>Create a mesh of the function <code>f</code> (from z-height and angle to radius). <code>fn</code> sets the number of angular steps around the z-axis.</p></div></div><h2 id="mesh-utilities"><a href="#mesh-utilities" class="anchor"></a>Mesh Utilities</h2><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>join ts</code></p><p>Join a list of meshes. This is not a boolean operation, it is simply collecting the points from each and updating face indices accordingly. Intended for use when building a closed mesh from a set of partial meshes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge_points" class="anchored"><a href="#val-merge_points" class="anchor"></a><code><span><span class="keyword">val</span> merge_points : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>merge_points ?eps t</code></p><p>Eliminate duplicate points (less than <code>eps</code> distance apart) from <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-drop_unused_points" class="anchored"><a href="#val-drop_unused_points" class="anchor"></a><code><span><span class="keyword">val</span> drop_unused_points : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>drop_unused_points t</code></p><p>Drop unreferenced points (not included in any face) from the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_face" class="anchored"><a href="#val-add_face" class="anchor"></a><code><span><span class="keyword">val</span> add_face : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_face face t</code></p><p>Add a single face to the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_faces" class="anchored"><a href="#val-add_faces" class="anchor"></a><code><span><span class="keyword">val</span> add_faces : <span><span><span>int list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_faces faces t</code></p><p>Add a list of faces to the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_faces" class="anchored"><a href="#val-rev_faces" class="anchor"></a><code><span><span class="keyword">val</span> rev_faces : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rev_faces t</code></p><p>Flip all faces of the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-volume" class="anchored"><a href="#val-volume" class="anchor"></a><code><span><span class="keyword">val</span> volume : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>volume t</code></p><p>Calculate the volume of the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-area" class="anchored"><a href="#val-area" class="anchor"></a><code><span><span class="keyword">val</span> area : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>area t</code></p><p>Calculate the surface area of the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-centroid" class="anchored"><a href="#val-centroid" class="anchor"></a><code><span><span class="keyword">val</span> centroid : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../V3/index.html#type-t">V3.t</a></span></code></div><div class="spec-doc"><p><code>centroid ?eps t</code></p><p>Calculate the centroid of the mesh <code>t</code>.</p></div></div><h2 id="basic-transfomations"><a href="#basic-transfomations" class="anchor"></a>Basic Transfomations</h2><div class="odoc-spec"><div class="spec value" id="val-translate" class="anchored"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-xtrans" class="anchored"><a href="#val-xtrans" class="anchor"></a><code><span><span class="keyword">val</span> xtrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ytrans" class="anchored"><a href="#val-ytrans" class="anchor"></a><code><span><span class="keyword">val</span> ytrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-ztrans" class="anchored"><a href="#val-ztrans" class="anchor"></a><code><span><span class="keyword">val</span> ztrans : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rotate" class="anchored"><a href="#val-rotate" class="anchor"></a><code><span><span class="keyword">val</span> rotate : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-xrot" class="anchored"><a href="#val-xrot" class="anchor"></a><code><span><span class="keyword">val</span> xrot : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-yrot" class="anchored"><a href="#val-yrot" class="anchor"></a><code><span><span class="keyword">val</span> yrot : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-zrot" class="anchored"><a href="#val-zrot" class="anchor"></a><code><span><span class="keyword">val</span> zrot : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-quaternion" class="anchored"><a href="#val-quaternion" class="anchor"></a><code><span><span class="keyword">val</span> quaternion : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Quaternion/index.html#type-t">Quaternion.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-axis_rotate" class="anchored"><a href="#val-axis_rotate" class="anchor"></a><code><span><span class="keyword">val</span> axis_rotate : <span>?about:<a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-affine" class="anchored"><a href="#val-affine" class="anchor"></a><code><span><span class="keyword">val</span> affine : <span><a href="../Affine3/index.html#type-t">Affine3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-scale" class="anchored"><a href="#val-scale" class="anchor"></a><code><span><span class="keyword">val</span> scale : <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-xscale" class="anchored"><a href="#val-xscale" class="anchor"></a><code><span><span class="keyword">val</span> xscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-yscale" class="anchored"><a href="#val-yscale" class="anchor"></a><code><span><span class="keyword">val</span> yscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-zscale" class="anchored"><a href="#val-zscale" class="anchor"></a><code><span><span class="keyword">val</span> zscale : <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mirror" class="anchored"><a href="#val-mirror" class="anchor"></a><code><span><span class="keyword">val</span> mirror : <span><a href="../V3/index.html#type-t">V3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div></div></body></html>