<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Math (OCADml.OCADml.Math)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">OCADml</a> &#x00BB; <a href="../index.html">OCADml</a> &#x00BB; Math</nav><header class="odoc-preamble"><h1>Module <code><span>OCADml.Math</span></code></h1><p>Various operations on floats (<i>e.g.</i> approximate equality, linear interpolation), and basic arbitrary size 2d matrix operations.</p></header><nav class="odoc-toc"><ul><li><a href="#float-operations">Float operations</a></li><li><a href="#angles-and-trigonometry">Angles and Trigonometry</a></li><li><a href="#2d-matrix-operations">2d matrix operations</a></li><li><a href="#polynomials">Polynomials</a></li><li><a href="#search">Search</a></li></ul></nav><div class="odoc-content"><h2 id="float-operations"><a href="#float-operations" class="anchor"></a>Float operations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-sign"><a href="#val-sign" class="anchor"></a><code><span><span class="keyword">val</span> sign : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>sign v</code></p><p>Return the sign of <code>v</code> as a float (<code>-1.</code>, <code>0.</code>, or <code>1.</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-clamp"><a href="#val-clamp" class="anchor"></a><code><span><span class="keyword">val</span> clamp : <span>min:float <span class="arrow">&#45;&gt;</span></span> <span>max:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>clamp ~min ~max v</code></p><p>Clamp the float <code>v</code> between <code>min</code> and <code>max</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lerp"><a href="#val-lerp" class="anchor"></a><code><span><span class="keyword">val</span> lerp : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>lerp a b u</code></p><p>Linearly interpolate between floats <code>a</code> and <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-lerpn"><a href="#val-lerpn" class="anchor"></a><code><span><span class="keyword">val</span> lerpn : <span>?endpoint:bool <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>float list</span></span></code></div><div class="spec-doc"><p><code>lerpn ?endpoint a b n</code></p><p>Linearly interpolate <code>n</code> values between <code>a</code> and <code>b</code>. If <code>endpoint</code> is <code>true</code>, the last value will be equal to <code>b</code>, otherwise, it will be about <code>a + (b - a) * (1 - 1 / n)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-quant"><a href="#val-quant" class="anchor"></a><code><span><span class="keyword">val</span> quant : <span>q:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>quant ~q v</code></p><p>Quantize <code>v</code> to a multiple of the quantum size <code>q</code>. For example:</p><pre class="language-ocaml"><code>quant ~q:0.2 1.5 = 1.6</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-quant_down"><a href="#val-quant_down" class="anchor"></a><code><span><span class="keyword">val</span> quant_down : <span>q:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>quant_down ~q v</code></p><p>Quantize <code>v</code> to a multiple of the quantum size <code>q</code>, always rounding down. For example:</p><pre class="language-ocaml"><code>quant_down ~q:0.2 1.75 = 1.6</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-quant_up"><a href="#val-quant_up" class="anchor"></a><code><span><span class="keyword">val</span> quant_up : <span>q:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>quant_up ~q v</code></p><p>Quantize <code>v</code> to a multiple of the quantum size <code>q</code>, always rounding up. For example:</p><pre class="language-ocaml"><code>quant_up ~q:0.2 1.51 = 1.6</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-approx"><a href="#val-approx" class="anchor"></a><code><span><span class="keyword">val</span> approx : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>approx ?eps a b</code></p><p>Return <code>true</code> if <code>a</code> is within the tolerance <code>eps</code> of <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-posmod"><a href="#val-posmod" class="anchor"></a><code><span><span class="keyword">val</span> posmod : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>posmod a m</code></p><p>Compute the positive modulo <code>m</code> of <code>a</code>. The resulting value will be in the range of <code>0</code> to <code>m - 1</code>.</p></div></div><h2 id="angles-and-trigonometry"><a href="#angles-and-trigonometry" class="anchor"></a>Angles and Trigonometry</h2><div class="odoc-spec"><div class="spec value anchored" id="val-deg_of_rad"><a href="#val-deg_of_rad" class="anchor"></a><code><span><span class="keyword">val</span> deg_of_rad : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>deg_of_rad r</code></p><p>Convert <code>r</code> from radians to degrees.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rad_of_deg"><a href="#val-rad_of_deg" class="anchor"></a><code><span><span class="keyword">val</span> rad_of_deg : <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>rad_of_deg d</code></p><p>Convert <code>d</code> from degrees to radians.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-law_of_cosines"><a href="#val-law_of_cosines" class="anchor"></a><code><span><span class="keyword">val</span> law_of_cosines : <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>law_of_cosines a b c</code></p><p>Apply the Law of Cosines for a triangle with side lengths <code>a</code>, <code>b</code>, and <code>c</code>. The angle in radians of the corner opposite of the third side <code>c</code> is returned.</p></div></div><h2 id="2d-matrix-operations"><a href="#2d-matrix-operations" class="anchor"></a>2d matrix operations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-mat_dims"><a href="#val-mat_dims" class="anchor"></a><code><span><span class="keyword">val</span> mat_dims : <span><span><span><span class="type-var">'a</span> array</span> array</span> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p><code>mat_dims m</code></p><p>Return the dimensions (<code>(n_rows, n_cols)</code> of the 2d matrix <code>m</code>. An <code>Invalid_argument</code> exception is raised if the row lengths are inconsistent.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-matmul"><a href="#val-matmul" class="anchor"></a><code><span><span class="keyword">val</span> matmul : <span><span><span>float array</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>float array</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span>float array</span> array</span></span></code></div><div class="spec-doc"><p><code>matmul a b</code></p><p>Matrix multiplication of <code>a</code> and <code>b</code>. <code>Invalid_argument</code> is raised if the inner dimensions do not match, or if the rows of either matrix are ragged.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-transpose"><a href="#val-transpose" class="anchor"></a><code><span><span class="keyword">val</span> transpose : <span><span><span><span class="type-var">'a</span> array</span> array</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> array</span> array</span></span></code></div><div class="spec-doc"><p><code>transpose m</code></p><p>Transpose rows and columns of the 2d matrix <code>m</code>.</p></div></div><h2 id="polynomials"><a href="#polynomials" class="anchor"></a>Polynomials</h2><div class="odoc-spec"><div class="spec value anchored" id="val-real_roots"><a href="#val-real_roots" class="anchor"></a><code><span><span class="keyword">val</span> real_roots : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span>?tol:float <span class="arrow">&#45;&gt;</span></span> <span><span>float array</span> <span class="arrow">&#45;&gt;</span></span> <span>float array</span></span></code></div><div class="spec-doc"><p><code>real_roots ?eps ?tol p</code></p><p>Compute the real roots of the real polynomial <code>p</code>. The polynomial is specified as <code>[|a_n; ...; a_1; a_0|]</code> where <code>a_n</code> is the <code>x ** n</code> coefficient.</p><ul><li><code>eps</code> is used to determine if the imaginary parts of the roots are zero</li><li><code>tol</code> is the tolerance for the complex polynomial root finder</li></ul><p>Adapted from the <code>real_roots</code> function found in the <a href="https://github.com/revarbat/BOSL2/blob/master/math.scad#L1361">BOSL2 math module</a>.</p></div></div><h2 id="search"><a href="#search" class="anchor"></a>Search</h2><div class="odoc-spec"><div class="spec value anchored" id="val-bisection"><a href="#val-bisection" class="anchor"></a><code><span><span class="keyword">val</span> bisection : 
  <span>?max_iter:int <span class="arrow">&#45;&gt;</span></span>
  <span>?tolerance:float <span class="arrow">&#45;&gt;</span></span>
  <span>lower:float <span class="arrow">&#45;&gt;</span></span>
  <span>upper:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>float <span class="arrow">&#45;&gt;</span></span> float)</span> <span class="arrow">&#45;&gt;</span></span>
  float</span></code></div><div class="spec-doc"><p><code>bisection ?max_iter ?tolerance ~lower ~upper f</code></p><p>Perform a <a href="https://en.wikipedia.org/wiki/Bisection_method">bisection</a> search for the value that minimizes the function <code>f</code> between the bounds <code>lower</code> and <code>upper</code>. <code>x</code> is returned either when <code>f x = 0.</code>, or the bound range falls below <code>tolerance</code>. Raises <code>Failure</code> if the iteration count reaches <code>max_iter</code> (default = <code>100</code>).</p></div></div></div></body></html>